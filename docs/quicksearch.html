<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"index.js.html":{"id":"index.js.html","title":"Source: index.js","body":" moize Modules moize Source: index.js // @flow // external dependencies import Map from 'map-or-similar'; // utils import { INFINITY, getCacheKey, getFunctionWithCacheAdded, serializeArguments, setNewCachedValue, setUsageOrder } from './utils'; type Options = { cache?: Map|Object, isCircular?: boolean, isPromise?: boolean, maxAge?: number, maxSize?: number, serializer?: Function }; /** * @module moize */ /** * @function moize * * @description * store cached values returned from calling method with arguments to avoid reprocessing data from same arguments * * @example * import moize from 'moize'; * * // standard implementation * const fn = (foo, bar) =&gt; { * return `${foo} ${bar}`; * }; * const memoizedFn = moize(fn); * * // implementation with options * const fn = async (id) =&gt; { * return get(`http://foo.com/${id}`); * }; * const memoizedFn = moize(fn, { * isPromise: true, * maxSize: 5 * }); * * @param {function} fn method to memoize * @param {Options} [options={}] options to customize how the caching is handled * @param {Map} [options.cache=new Map()] caching mechanism to use for method * @param {boolean} [options.isPromise=false] is the function return expected to be a promise to resolve * @param {number} [options.maxAge=Infinity] the maximum age the value should persist in cache * @param {number} [options.maxSize=Infinity] the maximum size of the cache to retain * @param {function} [options.serializer=serializeArguments] method to serialize arguments with for cache storage * @returns {Function} higher-order function which either returns from cache or newly-computed value */ const moize = function(fn: Function, options: Options = {}): any { const { cache = new Map(), isCircular = false, isPromise = false, maxAge = INFINITY, maxSize = INFINITY, serializer = serializeArguments } = options; const isMaxAgeFinite: boolean = maxAge !== INFINITY; const isMaxSizeFinite: boolean = maxSize !== INFINITY; let key: string = ''; /** * @private * * @function memoizedFunction * * @description * higher-order function which either returns from cache or stores newly-computed value and returns it * * @param {Array&lt;*&gt;} args arguments passed to method * @returns {any} value resulting from executing of fn passed to memoize */ const memoizedFunction = function(...args: Array&lt;any&gt;): any { key = getCacheKey(args, serializer, isCircular); if (isMaxSizeFinite) { setUsageOrder(memoizedFunction, key, maxSize); } if (memoizedFunction.cache.has(key)) { return memoizedFunction.cache.get(key); } return setNewCachedValue(memoizedFunction, key, fn.apply(this, args), isPromise, isMaxAgeFinite, maxAge); }; return getFunctionWithCacheAdded(memoizedFunction, cache); }; export default moize; × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" moize Modules moize Modules × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"index.html":{"id":"index.html","title":"Index","body":" moize Modules moize moize 1.0.1 moize moize strives to be the fastest possible implementation of memoization in JavaScript that supports all arguments passed, while offering flexibility in implementation. Table of contents Installation Usage Advanced usage Benchmarks Browser support Development Installation $ npm i moize --saveUsage import moize from 'moize'; const method = (a, b) =&gt; { return a + b; }; const memoized = moize(method); memoized(2, 4); // 6 memoized(2, 4); // 6, pulled from cacheAll parameter types are supported, including circular objects, functions, etc. You can even memoize functional React components based on their props + context combination! Advanced usage moize also accepts an object of options as the second parameter. The full shape of these options: { cache: Map|Object, // custom cache implementation isPromise: boolean, // is the result a promise maxAge: number, // amount of time in milliseconds before the cache will expire maxSize: number, // maximum size of cache for this method serializer: Function // method to serialize the arguments to build a unique cache key }cache defaults to new Map() The default cache implementation is highly performant, however if you would like then you can pass in a custom cache implementation. The only requirements for the cache implementation is that it matches the relevant Map API methods: delete get has set isPromise defaults to false Is the computed value in the function a Promise, and should we cache the resolved value from that Promise. maxAge defaults to Infinity The maximum amount of time in milliseconds that you want a computed value to be stored in cache for this method. maxSize defaults to Infinity The maximum size of the cache you want stored in cache for this method. Clearance of the cache once the maxSize is reached is on a Least Recently Used basis. seralizer defaults to serializeArguments in utils.js The default seralizer method is highly performant, and covers a number of edge cases (recursive objects, for example), however if you want to provide a custom one you may. The value returned from the function must be a valid value of keys for a Map. Benchmarks All values provided are the number of operations per second (ops/sec) calculated by the Benchmark suite. Note that underscore, lodash, and ramda do not support mulitple-parameter memoization, so they are not included in those benchmarks. underscore lodash ramda memoizee fast-memoize addy-osmani memoizerific moize 6,173,721 6,964,896 251,801 4,140,779 5,950,556 1,786,883 920,642 10,105,377 memoizee fast-memoize addy-osmani memoizerific moize 3,121,912 247,767 985,573 742,577 3,291,722 memoizee fast-memoize addy-osmani memoizerific moize 3,363 221,302 470,113 32,307 650,998 Browser support Chrome (all versions) Firefox (all versions) Opera 15+ Edge (all versions) IE 9+ Safari 6+ Theoretically the support should go back even farther, these are just the environments that I have tested. Development Standard stuff, clone the repo and npm install dependencies. The npm scripts available: build =&gt; run webpack to build development dist file with NODE_ENV=development build:minifed =&gt; run webpack to build production dist file with NODE_ENV=production dev =&gt; run webpack dev server to run example app (playground!) dist =&gt; runs build and build-minified docs =&gt; builds the docs via jsdoc lint =&gt; run ESLint against all files in the src folder prepublish =&gt; runs compile-for-publish prepublish:compile =&gt; run lint, test, transpile, dist test =&gt; run AVA test functions with NODE_ENV=test test:coverage =&gt; run test but with nyc for coverage checker test:watch =&gt; run test, but with persistent watcher transpile =&gt; run babel against all files in src to create files in lib × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"module-moize.html":{"id":"module-moize.html","title":"Module: moize","body":" moize Modules moize Module: moize Source: index.js, line 15 Methods &lt;inner&gt; moize(fn [, options]) store cached values returned from calling method with arguments to avoid reprocessing data from same arguments Parameters: Name Type Argument Default Description fn function method to memoize options Options &lt;optional&gt; {} options to customize how the caching is handled Properties Name Type Argument Default Description cache Map &lt;optional&gt; new Map() caching mechanism to use for method isPromise boolean &lt;optional&gt; false is the function return expected to be a promise to resolve maxAge number &lt;optional&gt; Infinity the maximum age the value should persist in cache maxSize number &lt;optional&gt; Infinity the maximum size of the cache to retain serializer function &lt;optional&gt; serializeArguments method to serialize arguments with for cache storage Source: index.js, line 19 Returns: higher-order function which either returns from cache or newly-computed value Type function Example import moize from 'moize'; // standard implementation const fn = (foo, bar) =&gt; { return `${foo} ${bar}`; }; const memoizedFn = moize(fn); // implementation with options const fn = async (id) =&gt; { return get(`http://foo.com/${id}`); }; const memoizedFn = moize(fn, { isPromise: true, maxSize: 5 }); × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
