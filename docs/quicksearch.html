<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"Cache.js.html":{"id":"Cache.js.html","title":"Source: Cache.js","body":" moize Modules moize Source: Cache.js // @flow // types import type {ListItem} from './types'; // utils import {findIndex, findIndexAfterFirst, splice, unshift} from './utils'; /** * @private * * @class Cache * * @classdesc * class that is similar to the Map infrastructure, but faster and * more targeted to moize use cases */ class Cache { lastItem: ListItem = {}; list: Array&lt;ListItem&gt; = []; size: number = 0; /** * @function add * @memberof Cache * @instance * * @description * add a new item to cache * * @param {*} key the key to assign * @param {*} value the value to assign at key */ add(key: any, value: any): any { this.lastItem = unshift(this.list, { key, value }); this.size++; } /** * @function clear * @memberof Cache * @instance * * @description * clear the cache of all items */ clear() { this.lastItem = {}; this.list.length = this.size = 0; } /** * @function expireAfter * @memberof Cache * @instance * * @description * remove from cache after maxAge time has passed * * @param {*} key the key to remove * @param {number} maxAge the time in milliseconds to wait before removing key */ expireAfter(key: any, maxAge: number) { setTimeout(() =&gt; { this.remove(key); }, maxAge); } /** * @function get * @memberof Cache * @instance * * @description * get the value of an item from cache if it exists * * @param {*} key the key to get the value of * @returns {*} the value at key */ get(key: any): any { if (!this.size) { return; } if (key === this.lastItem.key) { return this.lastItem.value; } const index: number = findIndexAfterFirst(this.list, key); if (~index) { this.lastItem = this.list[index]; return unshift(splice(this.list, index), this.lastItem).value; } } /** * @private * * @function has * * @description * does the key exist in the cache * * @param {*} key the key to find in cache * @returns {boolean} does the key exist in cache */ has(key: any): boolean { return ( this.size !== 0 &amp;&amp; (key === this.lastItem.key || !!~findIndexAfterFirst(this.list, key)) ); } /**= * @function remove * @memberof Cache * @instance * * @description * remove the item at key from cach * * @param {*} key the key to remove from cache * @returns {void} */ remove(key: any) { const index: number = findIndex(this.list, key); if (~index) { splice(this.list, index); if (this.size === 1) { return this.clear(); } this.size--; if (!index) { this.lastItem = this.list[0]; } } } /** * @function update * @memberof Cache * @instance * * @description * update an item in-place with a new value * * @param {*} key key to update value of * @param {*} value value to store in the map at key */ update(key: any, value: any) { const index: number = findIndex(this.list, key); if (~index) { this.list[index].value = value; if (this.lastItem &amp;&amp; key === this.lastItem.key) { this.lastItem.value = value; } } } } export default Cache; × Search results Close Documentation generated by JSDoc 3.5.3 using the DocStrap template. "},"index.js.html":{"id":"index.js.html","title":"Source: index.js","body":" moize Modules moize Source: index.js // @flow // cache import Cache from './Cache'; // constants import { INVALID_FIRST_PARAMETER_ERROR, PROMISE_OPTIONS, REACT_OPTIONS, SERIALIZE_OPTIONS } from './constants'; // types import type {Options} from './types'; // utils import { compose, createAddPropertiesToFunction, createCurriableOptionMethod, createGetCacheKey, createSetNewCachedValue, getDefaultedOptions, isFunction, isMoized, isPlainObject } from './utils'; /** * @module moize */ /** * @function moize * * @description * store cached values returned from calling method with arguments to avoid reprocessing data from same arguments * * @example * import moize from 'moize'; * * // standard implementation * const fn = (foo, bar) =&gt; { * return `${foo} ${bar}`; * }; * const memoizedFn = moize(fn); * * // implementation with options * const fn = async (id) =&gt; { * return get(`http://foo.com/${id}`); * }; * const memoizedFn = moize(fn, { * isPromise: true, * maxSize: 5 * }); * * @param {function} functionOrComposableOptions method to memoize * @param {Options} [passedOptions={}] options to customize how the caching is handled * @param {boolean} [passedOptions.isPromise=false] is the function return expected to be a promise to resolve * @param {number} [passedOptions.maxAge=Infinity] the maximum age the value should persist in cache * @param {number} [passedOptions.maxArgs=Infinity] the maximum number of arguments to be used in serializing the keys * @param {number} [passedOptions.maxSize=Infinity] the maximum size of the cache to retain * @param {function} [passedOptions.promiseLibrary=Promise] promise library to use for resolution / rejection * @param {function} [passedOptions.serializeFunctions=false] should function parameters be serialized as well * @param {function} [passedOptions.serializer] method to serialize arguments with for cache storage * @returns {Function} higher-order function which either returns from cache or newly-computed value */ const moize: Function = ( functionOrComposableOptions: Function | Object, passedOptions: Object = {} ): Function =&gt; { if (isPlainObject(functionOrComposableOptions)) { return function( fnOrOptions: Function | Object, otherOptions: Object = {} ): Function { if (isPlainObject(fnOrOptions)) { return moize({ // $FlowIgnore functionOrComposableOptions is object of options ...functionOrComposableOptions, // $FlowIgnore fnOrOptions is object of options ...fnOrOptions }); } return moize(fnOrOptions, { // $FlowIgnore functionOrComposableOptions is object of options ...functionOrComposableOptions, ...otherOptions }); }; } if (!isFunction(functionOrComposableOptions)) { throw new TypeError(INVALID_FIRST_PARAMETER_ERROR); } const isComposed: boolean = functionOrComposableOptions.isMoized; // $FlowIgnore if the function is already moized, it has an originalFunction property on it const fn: Function = isComposed ? functionOrComposableOptions.originalFunction : functionOrComposableOptions; const options: Options = getDefaultedOptions( !isComposed ? passedOptions : { ...functionOrComposableOptions.options, ...passedOptions } ); const cache: Cache = new Cache(); const addPropertiesToFunction: Function = createAddPropertiesToFunction( cache, fn, options ); const getCacheKey: Function = createGetCacheKey(cache, options); const setNewCachedValue: Function = createSetNewCachedValue(cache, options); const moizedFunction: Function = function(...args: Array&lt;any&gt;): any { const key: any = getCacheKey(args); return cache.size &amp;&amp; cache.has(key) ? cache.get(key) : setNewCachedValue(key, fn.apply(this, args)); }; return addPropertiesToFunction(moizedFunction); }; moize.compose = compose; moize.isMoized = isMoized; moize.maxAge = createCurriableOptionMethod(moize, 'maxAge'); moize.maxArgs = createCurriableOptionMethod(moize, 'maxArgs'); moize.maxSize = createCurriableOptionMethod(moize, 'maxSize'); moize.promise = moize(PROMISE_OPTIONS); moize.react = moize(REACT_OPTIONS); moize.reactSimple = compose(moize.react, moize.maxSize(1)); moize.serialize = moize(SERIALIZE_OPTIONS); moize.simple = moize.maxSize(1); export default moize; × Search results Close Documentation generated by JSDoc 3.5.3 using the DocStrap template. "},"MultipleParameterCacheKey.js.html":{"id":"MultipleParameterCacheKey.js.html","title":"Source: MultipleParameterCacheKey.js","body":" moize Modules moize Source: MultipleParameterCacheKey.js // @flow /** * @private * * @class MultipleParameterCacheKey * * @classdesc * cache key used when there are multiple standard parameters */ class MultipleParameterCacheKey { constructor(key: Array&lt;any&gt;) { this.key = key; this.size = key.length; return this; } isMultiParamKey: boolean = true; key: any = null; size: number = 0; /** * @function matches * @memberof MultipleParameterCacheKey * @instance * * @description * does the passed key match the key in the instance * * @param {Array&lt;*&gt;} key the key to test * @param {boolean} isMultiParamKey is the key a multi-parameter key * @returns {boolean} does the key passed match that in the instance */ matches(key: Array&lt;any&gt;, isMultiParamKey: boolean): boolean { if (!isMultiParamKey || key.length !== this.size) { return false; } let index: number = 0; while (index &lt; this.size) { if (key[index] !== this.key[index]) { return false; } index++; } return true; } /** * @function matchesCustom * @memberof SingleParameterCacheKey * @instance * * @description * does the passed key match the key in the instance based on the custom equality function passed * * @param {Array&lt;*&gt;} key the key to test * @param {boolean} isMultiParamKey is the key a multi-parameter key * @param {function} isEqual method to compare equality of the keys * @returns {boolean} does the key passed match that in the instance */ matchesCustom( key: Array&lt;any&gt;, isMultiParamKey: boolean, isEqual: Function ): boolean { if (!isMultiParamKey || key.length !== this.size) { return false; } let index: number = 0; while (index &lt; this.size) { if (!isEqual(key[index], this.key[index])) { return false; } index++; } return true; } } export default MultipleParameterCacheKey; × Search results Close Documentation generated by JSDoc 3.5.3 using the DocStrap template. "},"ReactCacheKey.js.html":{"id":"ReactCacheKey.js.html","title":"Source: ReactCacheKey.js","body":" moize Modules moize Source: ReactCacheKey.js // @flow /** * @private * * @class ReactCacheKey * * @classdesc * cache key used specifically for react components */ class ReactCacheKey { constructor(key: Array&lt;Object&gt;) { const context = key[1]; const props = key[0]; this.key = { context, contextSize: context ? Object.keys(context).length : 0, props, propsSize: props ? Object.keys(props).length : 0 }; return this; } key: any = null; /** * @function _isPropShallowEqual * @memberof ReactCacheKey * @instance * * @description * check if the prop value passed is equal to the key's value * * @param {string} prop the key property to test * @param {Object} object the value of the key to test against * @returns {boolean} is the prop value shallow equal to the object */ _isPropShallowEqual(prop: string, object: Object): boolean { const keys: Array&lt;string&gt; = Object.keys(object); if (keys.length !== this.key[`${prop}Size`]) { return false; } let index: number = 0; while (index &lt; keys.length) { if (object[keys[index]] !== this.key[prop][keys[index]]) { return false; } index++; } return true; } /** * @function _isPropCustomEqual * @memberof ReactCacheKey * @instance * * @description * check if the prop value passed is equal to the key's value * * @param {string} prop the key property to test * @param {Object} object the value of the key to test against * @param {function} isEqual method to check equality of keys * @returns {boolean} is the prop value shallow equal to the object */ _isPropCustomEqual(prop: string, object: Object, isEqual: Function): boolean { const keys: Array&lt;string&gt; = Object.keys(object); if (keys.length !== this.key[`${prop}Size`]) { return false; } let index: number = 0; while (index &lt; keys.length) { if (!isEqual(object[keys[index]], this.key[prop][keys[index]])) { return false; } index++; } return true; } /** * @function matches * @memberof ReactCacheKey * @instance * * @description * does the passed key match the key in the instance * * @param {Array&lt;*&gt;} key the key to test * @returns {boolean} does the key passed match that in the instance */ matches(key: Array&lt;Object&gt;): boolean { return ( this._isPropShallowEqual('props', key[0]) &amp;&amp; this._isPropShallowEqual('context', key[1]) ); } /** * @function matchesCustom * @memberof ReactCacheKey * @instance * * @description * does the passed key match the key in the instance * * @param {Array&lt;*&gt;} key the key to test * @param {function} isEqual method to check equality of keys * @returns {boolean} does the key passed match that in the instance */ matchesCustom(key: Array&lt;Object&gt;, isEqual: Function): boolean { return ( this._isPropCustomEqual('props', key[0], isEqual) &amp;&amp; this._isPropCustomEqual('context', key[1], isEqual) ); } } export default ReactCacheKey; × Search results Close Documentation generated by JSDoc 3.5.3 using the DocStrap template. "},"SerializedCacheKey.js.html":{"id":"SerializedCacheKey.js.html","title":"Source: SerializedCacheKey.js","body":" moize Modules moize Source: SerializedCacheKey.js // @flow /** * @private * * @class SerializedCacheKey * * @classdesc * cache key used when the parameters should be serialized */ class SerializedCacheKey { constructor(key: Array&lt;any&gt;) { this.key = key; return this; } key: any = null; /** * @function matches * @memberof SerializedCacheKey * @instance * * @description * does the passed key match the key in the instance *W * @param {Array&lt;*&gt;} key the key to test * @returns {boolean} does the key passed match that in the instance */ matches(key: Array&lt;any&gt;): boolean { return key === this.key; } /** * @function matchesCustom * @memberof SerializedCacheKey * @instance * * @description * does the passed key match the key in the instance based on the custom equality function passed * * @param {Array&lt;*&gt;} key the key to test * @param {function} isEqual method to compare equality of the keys * @returns {boolean} does the key passed match that in the instance */ matchesCustom(key: Array&lt;any&gt;, isEqual: Function): boolean { return isEqual(key, this.key); } } export default SerializedCacheKey; × Search results Close Documentation generated by JSDoc 3.5.3 using the DocStrap template. "},"SingleParameterCacheKey.js.html":{"id":"SingleParameterCacheKey.js.html","title":"Source: SingleParameterCacheKey.js","body":" moize Modules moize Source: SingleParameterCacheKey.js // @flow /** * @private * * @class SingleParameterCacheKey * * @classdesc * cache key used when there is a single standard parameter */ class SingleParameterCacheKey { constructor(key: Array&lt;any&gt;) { this.key = key[0]; return this; } isMultiParamKey: boolean = false; key: any = null; /** * @function matches * @memberof SingleParameterCacheKey * @instance * * @description * does the passed key match the key in the instance * * @param {Array&lt;*&gt;} key the key to test * @param {boolean} isMultiParamKey is the key a multi-parameter key * @returns {boolean} does the key passed match that in the instance */ matches(key: Array&lt;any&gt;, isMultiParamKey: boolean): boolean { return !isMultiParamKey &amp;&amp; key[0] === this.key; } /** * @function matchesCustom * @memberof SingleParameterCacheKey * @instance * * @description * does the passed key match the key in the instance based on the custom equality function passed * * @param {Array&lt;*&gt;} key the key to test * @param {boolean} isMultiParamKey is the key a multi-parameter key * @param {function} isEqual method to compare equality of the keys * @returns {boolean} does the key passed match that in the instance */ matchesCustom( key: Array&lt;any&gt;, isMultiParamKey: boolean, isEqual: Function ): boolean { return !isMultiParamKey &amp;&amp; isEqual(key[0], this.key); } } export default SingleParameterCacheKey; × Search results Close Documentation generated by JSDoc 3.5.3 using the DocStrap template. "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" moize Modules moize Modules × Search results Close Documentation generated by JSDoc 3.5.3 using the DocStrap template. "},"index.html":{"id":"index.html","title":"Index","body":" moize Modules moize moize 3.1.0 moize moize is a blazing fast memoization library for JavaScript. It handles multiple parameters (including default values) without any additional configuration, and offers options to help satisfy a number of implementation-specific needs. It has no dependencies, and is ~3.4kb when minified and gzipped. Table of contents Upgrade notification Installation Usage Advanced usage equals isPromise isReact maxAge maxArgs maxSize promiseLibrary serialize serializeFunctions serializer Usage with shortcut methods moize.maxAge moize.maxArgs moize.maxSize moize.promise moize.react moize.reactSimple moize.serialize moize.simple Composition Introspection isMoized Benchmarks Single parameter Multiple parameters (primitives only) Multiple parameters (complex objects) Direct cache manipulation add clear has keys remove values Browser support Development Upgrade notification Users of moize 2.x.x may experience breaking changes, especially if using a custom cache or using moize.react in a mutative way. Please see the changelog for more details about how to manage the upgrade. Installation $ npm i moize --saveUsage import moize from 'moize'; const method = (a, b) =&gt; { return a + b; }; const memoized = moize(method); memoized(2, 4); // 6 memoized(2, 4); // 6, pulled from cacheAll parameter types are supported, including circular objects, functions, etc. There are also a number of shortcut methods to easily create memoization for targeted use-cases. You can even memoize functional React components based on their props + context combination (see the isReact option, or the moize.react shortcut method)! Advanced usage moize optionally accepts an object of options as either the second parameter or as the first step in a curried function: // inline moize(fn, options); // curried moize(options)(fn);The full shape of these options: { equals: Function, // custom method to compare equality between two objects isPromise: boolean, // is the result a promise isReact: boolean, // is the result a React component maxAge: number, // amount of time in milliseconds before the cache will expire maxArgs: number, // maximum number of arguments to use as key for caching maxSize: number, // maximum size of cache for this method promiseLibrary: Function|Object, // promise library to use when isPromise is true, if not using native promises serialize: boolean, // should the parameters be serialized instead of directly referenced serializeFunctions: boolean, // should functions be included in the serialization of multiple parameters serializer: Function // method to serialize the arguments to build a unique cache key }equals defaults to strict equality Custom method used to compare equality of keys for cache purposes. // using lodash's deep equal comparison method import isEqual from 'lodash/isEqual'; const fn = ({foo, bar}) =&gt; { return [foo, bar]; }; const memoized = moize(fn, { equals: isEqual }); memoized({foo: 'foo', bar: 'bar'}); memoized({foo: 'foo', bar: 'bar'}); // pulls from cacheThe equals method receives two parameters (cache key values) and should return a boolean. Please note that this will be slower than the default strict equality comparison, however how much slower is based on the efficiency of the method passed. isPromise defaults to false Is the computed value in the function a Promise, and should we cache the resolved value from that Promise. This is also available via the shortcut method of moize.promise. const fn = async (item) =&gt; { return await item; }; const memoized = moize(fn, { isPromise: true });The resolved value of the Promise will be stored in cache as a Promise itself, so that cached returns will always be in the form of a Promise. For common usage reasons, if the Promise is rejected, the cache entry will be deleted. Also, if a maxAge is provided, the countdown of that TTL will begin upon the resolution of the promise rather than at the instantiation of it. isReact defaults to false Is the function passed a stateless functional React component. This is also available via the shortcut method of moize.react. const Foo = ({bar, baz}) =&gt; { return ( &lt;div&gt; {bar}: {baz} &lt;/div&gt; ); }; export default moize(Foo, { isReact: true });The method will do a shallow comparison of both props and context of the component based on strict equality. If you have mutative props and instead want to do a deep equals comparison, provide a custom equals option. maxAge defaults to Infinity The maximum amount of time in milliseconds that you want a computed value to be stored in cache for this method. This is also available via the shortcut method of moize.maxAge. const fn = (item) =&gt; { return item; }; const memoized = moize(fn, { maxAge: 1000 * 60 * 5 // five minutes });maxArgs defaults to the length of arguments passed to the method The maximum number of arguments used in creating the key for the cache. This is also available via the shortcut method of moize.maxArgs. const fn = (item1, item2, item3) =&gt; { return item1 + item2 + item3; }; const memoized = moize(fn, { maxArgs: 2 }); memoize('foo', 'bar', 'baz'); memoize('foo', 'bar', 'quz'); // pulls from cache, as the first two args are the samemaxSize defaults to Infinity The maximum number of values you want stored in cache for this method. Clearance of the cache once the maxSize is reached is on a Least Recently Used basis. This is also available via the shortcut method of moize.maxSize. const fn = (item) =&gt; { return item; }; const memoized = moize(fn, { maxSize: 5 });promiseLibrary defaults to native Promise The promise library to use for resolution / rejection of promises. const fn = (foo) =&gt; { return new Bluebird((resolve) =&gt; { resolve(foo); }); }; const memoized = moize(fn, { isPromise: true, promiseLibrary: Bluebird });Please note that for this option to work isPromise must be set to true. You can use any library where the following aspects of the specification are included: It is thenable (the generated promise has a .then() function) The Promise object itself has .resolve() and .reject() functions on it Most modern libraries (bluebird, q, etc.) include these by default, however if you are using a custom library that does not meet these requirements then you will need to implement them yourself. An example of a wrapper that creates the .resolve() and .reject() methods: import foo from 'my-promise-library'; // create a wrapper so as not to touch the library itself const customPromise = (fn) =&gt; { return foo(fn); }; // lets pretend foo has a .result() method that has the first // parameter as successful, second as failure customPromise.resolve = function(value) { return foo.result(value); }; customPromise.reject = function(error) { return foo.result(undefined, error); }; const fn = (foo) =&gt; { return customPromise((resolve) =&gt; { resolve(foo); }); }; const memoized = moize(fn, { isPromise: true, promiseLibrary: customPromise });serialize defaults to false Serializes the parameters passed into a string and uses this as the key for cache comparison. This is also available via the shortcut method of moize.serialize. const fn = (mutableObject) =&gt; { return mutableObject.foo; }; const memoized = moize(fn, { serialize: true }); const object = { foo: 'foo' }; memoized(object); // 'foo' object.foo = 'bar'; memoized(object); // 'bar'Please note that this is slower than the default key storage (see benchmarks). serializeFunctions defaults to false A custom replacer is used when serializing to ensure functions are included in the key serialization. const FunctionalComponent = ({onClickFoo}) =&gt; { return ( &lt;button onClick={onClickFoo} type=&quot;button&quot; &gt; Click me! &lt;/button&gt; ) }; const MemoizedFunctionalComponent = moize(FunctionalComponent, { serialize: true, serializeFunctions: true });Please note that you must also set serialize to true for this setting to take effect. serializer defaults to serializeArguments in utils.js Overrides the internal serializer when serializing the parameters for cache key comparison. The value returned from the function must be a valid value of keys for a Map; it does not need to a string, but should be unique from a strict equality perspective. const serializer = (args) =&gt; { return JSON.stringify(args[0]); }; const memoized = moize(fn, { serialize: true, serializer });Please note that you must also set serialize to true for this setting to take effect. Usage with shortcut methods moize.maxAge Pre-applies the maxAge option as a curriable method. import moize from 'moize'; const foo = (bar, baz) =&gt; { return `${bar} ${baz}`; }; export default moize.maxAge(5000)(foo);moize.maxArgs Pre-applies the maxArgs option as a curriable method. import moize from 'moize'; const foo = (bar, baz) =&gt; { return `${bar} ${baz}`; }; export default moize.maxArgs(1)(foo);moize.maxSize Pre-applies the maxSize option as a curriable method. import moize from 'moize'; const foo = (bar, baz) =&gt; { return `${bar} ${baz}`; }; export default moize.maxSize(5)(foo);moize.promise Pre-applies the isPromise option. import moize from 'moize'; const foo = async (bar, baz) =&gt; { return await someApiCall(bar, baz); }; export default moize.promise(foo);Please note that if you want to provide a custom promiseLibrary, you must do so with additional options: const additionalOptions = { promiseLibrary: Bluebird }; moize.promise(fn, additionalOptions); // or moize.promise(additionalOptions)(fn);moize.react Shortcut for memoizing functional components in React. This uses a special cache key that will do a shallow equal comparison of changes to both props and context. import moize from 'moize'; const Foo = ({bar, baz}) =&gt; { return ( &lt;div&gt; {bar} {baz} &lt;/div&gt; ); }; export default moize.react(Foo);Also, it should be noted that in usages that involve a lot of variety in the parameter changes, this has the potential for excessive memory consumption, as the cache will retain the history of all elements. It is therefore recommended to apply a maxSize, or to use the shortcut method moize.reactSimple, which automatically sets the maxSize to 1. Please note moize.react will not operate with components made via the class instantiation, as they do not offer the same referential transparency. moize.reactSimple Shortcut for memoizing functional components in React, with the cache size limited to a single entry. This mimics the PureComponent optimization, where the cache will only contain the component with the most recent props and context combination. import moize from 'moize'; const Foo = ({bar, baz}) =&gt; { return ( &lt;div&gt; {bar} {baz} &lt;/div&gt; ); }; export default moize.reactSimple(Foo);Please note moize.reactSimple will not operate with components made via the class instantiation, as they do not offer the same referential transparency. moize.serialize Pre-applies the serialize option. import moize from 'moize'; const foo = (bar, baz) =&gt; { return `${bar} ${baz}`; }; export default moize.serialize(foo);Please note that if you want to serializeFunctions or provide a custom serializer, you must do so with additional options: const additionalOptions = { serializeFunctions: true }; moize.serialize(fn, additionalOptions); // or moize.serialize(additionalOptions)(fn);moize.simple Pre-applies the maxSize option with 1. import moize from 'moize'; const foo = (bar, baz) =&gt; { return `${bar} ${baz}`; }; export default moize.simple(foo);Composition Starting with version 2.3.0, you can compose moize methods. This will create a new memoized method with the original function that shallowly merges the options of the two setups. Example: import moize from 'moize'; const Foo = (props) =&gt; { return ( &lt;div {...props}/&gt; ); }; // memoizing with react, as since 2.0.0 const MemoizedFoo = moize.react(Foo); // creating a separately-memoized method that has maxSize of 5 const LastFiveFoo = moize.maxSize(5)(MemoizedFoo);You can also create an options-first curriable version of moize if you only pass the options: import moize from 'moize'; // creates a function that will memoize what is passed const limitedSerializedMoize = moize({ maxSize: 5, serialize: true }); const foo = (bird) =&gt; { return `${bird} is the word`; }; const moizedFoo = limitedSerializedMoize(foo);You can also combine all of these options with moize.compose to create moize wrappers with pre-defined options. import moize from 'moize'; // creates a moizer that will have the options of // {isReact: true, maxAge: 5000, maxSize: 5} const superLimitedReactMoize = moize.compose(moize.react, moize.maxSize(5), moize.maxAge(5000));Introspection There currently is only one method to introspect objects specific to moize, but if you want more just ask! isMoized Is the function passed a moized function. const fn = () =&gt; {}; const moizedFn = moize(fn); moize.isMoized(fn); // false moize.isMoized(moizedFn); // trueBenchmarks All values provided are the number of operations per second (ops/sec) calculated by the Benchmark suite. Note that underscore, lodash, and ramda do not support mulitple-parameter memoization, so they are not included in those benchmarks. Each benchmark was performed using the default configuration of the library, with a fibonacci calculation based on a starting parameter of 35, and in the case of multiple parameters a second parameter (boolean for primitives, object for complex objects) was used. Single parameter Operations / second Relative margin of error moize 44,547,124 0.64% fast-memoize 30,048,291 0.97% moize (serialized) 14,877,726 0.63% underscore 13,821,853 0.61% memoizee 11,494,292 0.90% lodash 10,020,324 0.52% lru-memoize 10,017,832 1.30% Addy Osmani 4,423,578 0.76% memoizerific 2,174,503 1.31% ramda 1,171,053 0.71% Multiple parameters (primitives only) Operations / second Relative margin of error moize 24,947,214 0.77% moize (serialized) 10,982,454 0.84% memoizee 8,602,634 0.59% lru-memoize 7,667,460 1.58% Addy Osmani 2,039,761 0.86% memoizerific 1,336,321 0.81% fast-memoize 844,633 0.76% Multiple parameters (complex objects) Operations / second Relative margin of error moize 24,146,198 1.16% memoizee 8,324,025 0.86% lru-memoize 7,986,555 1.15% moize (serialized) 1,798,895 0.95% memoizerific 1,416,617 1.15% Addy Osmani 1,097,775 0.78% fast-memoize 746,371 1.03% Direct cache manipulation There are a few methods provided on the moized function which allow for programmatic manipulation of the cache: add(key, value) This will manually add the value at key in cache if key does not already exist. key is an Array of values, meant to reflect the arguments passed to the method. // single parameter is straightforward const memoized = moize((item) =&gt; { return item; }); memoized.add(['foo'], 'bar'); // pulls from cache memoized('foo');clear() This will clear all values in the cache, resetting it to an empty state. const memoized = moize((item) =&gt; { return item; }); memoized.clear();has(key) This will return true if a cache entry exists for the key passed, else will return false. key is an Array of values, meant to reflect the arguments passed to the method. const memoized = moize((first, second) =&gt; { return [first, second]; }); memoized('foo', 'bar'); console.log(memoized.has(['foo', 'bar'])); // true console.log(memoized.has(['bar', 'baz'])); // falsekeys() This will return a list of the current keys in cache. const memoized = moize((item) =&gt; { return item; }); const foo = 'foo'; memoized(foo); const bar = { baz: 'baz' }; memoized(bar); const keys = memoized.keys(); // ['foo', {baz: 'baz'}]remove(key) This will remove the provided key from cache. key is an Array of values, meant to reflect the arguments passed to the method. const memoized = moize((item) =&gt; { return item; }); const foo = { bar: 'baz' }; memoized(foo); memoized.remove([foo]); // will re-execute, as it is no longer in cache memoized(foo);values() This will return a list of the current values in cache when the native Cache. const memoized = moize((item) =&gt; { return { item }; }); const foo = 'foo'; memoized(foo); const bar = { baz: 'baz' }; memoized(bar); const values = memoized.values(); // [{item: 'foo'}, {item: {baz: 'baz'}}]Browser support Chrome (all versions) Firefox (all versions) Edge (all versions) Opera 15+ IE 9+ Safari 6+ iOS 8+ Android 4+ Development Standard stuff, clone the repo and npm install dependencies. The npm scripts available: build =&gt; run webpack to build development dist file with NODE_ENV=development build:minifed =&gt; run webpack to build production dist file with NODE_ENV=production dev =&gt; run webpack dev server to run example app (playground!) dist =&gt; runs build and build-minified docs =&gt; builds the docs via jsdoc lint =&gt; run ESLint against all files in the src folder prepublish =&gt; runs compile-for-publish prepublish:compile =&gt; run lint, test, transpile, dist test =&gt; run AVA test functions with NODE_ENV=test test:coverage =&gt; run test but with nyc for coverage checker test:watch =&gt; run test, but with persistent watcher transpile =&gt; run babel against all files in src to create files in lib × Search results Close Documentation generated by JSDoc 3.5.3 using the DocStrap template. "},"module-moize.html":{"id":"module-moize.html","title":"Module: moize","body":" moize Modules moize Module: moize Source: index.js, line 29 Methods &lt;inner&gt; moize(functionOrComposableOptions [, passedOptions]) store cached values returned from calling method with arguments to avoid reprocessing data from same arguments Parameters: Name Type Argument Default Description functionOrComposableOptions function method to memoize passedOptions Options &lt;optional&gt; {} options to customize how the caching is handled Properties Name Type Argument Default Description isPromise boolean &lt;optional&gt; false is the function return expected to be a promise to resolve maxAge number &lt;optional&gt; Infinity the maximum age the value should persist in cache maxArgs number &lt;optional&gt; Infinity the maximum number of arguments to be used in serializing the keys maxSize number &lt;optional&gt; Infinity the maximum size of the cache to retain promiseLibrary function &lt;optional&gt; Promise promise library to use for resolution / rejection serializeFunctions function &lt;optional&gt; false should function parameters be serialized as well serializer function &lt;optional&gt; method to serialize arguments with for cache storage Source: index.js, line 33 Returns: higher-order function which either returns from cache or newly-computed value Type function Example import moize from 'moize'; // standard implementation const fn = (foo, bar) =&gt; { return `${foo} ${bar}`; }; const memoizedFn = moize(fn); // implementation with options const fn = async (id) =&gt; { return get(`http://foo.com/${id}`); }; const memoizedFn = moize(fn, { isPromise: true, maxSize: 5 }); × Search results Close Documentation generated by JSDoc 3.5.3 using the DocStrap template. "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
