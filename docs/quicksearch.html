<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"ReactCacheKey.js.html":{"id":"ReactCacheKey.js.html","title":"Source: ReactCacheKey.js","body":" moize Modules moize Classes CacheMultipleParameterCacheKeyReactCacheKeySerializedCacheKeySingleParameterCacheKey Global _isPropShallowEqualaddcleargetgetReactCacheKeygetSerializedCacheKeygetStandardCacheKeyhasmatchesPROMISE_OPTIONSREACT_OPTIONSremoveSERIALIZE_OPTIONS Source: ReactCacheKey.js // @flow /** * @class ReactCacheKey * * @classdesc * cache key used specifically for react components */ class ReactCacheKey { constructor(key: Array&lt;Object&gt;) { const context = key[1]; const props = key[0]; this.key = { context, contextSize: context ? Object.keys(context).length : 0, props, propsSize: props ? Object.keys(props).length : 0 }; return this; } key: any = null; /** * @function _isPropShallowEqual * * @description * check if the prop value passed is equal to the key's value * * @param {string} prop the key property to test * @param {Object} object the value of the key to test against * @returns {boolean} is the prop value shallow equal to the object */ _isPropShallowEqual(prop: string, object: Object): boolean { const keys: Array&lt;string&gt; = Object.keys(object); if (keys.length !== this.key[`${prop}Size`]) { return false; } let index: number = 0; while (index &lt; keys.length) { if (object[keys[index]] !== this.key[prop][keys[index]]) { return false; } index++; } return true; } /** * @function matches * * @description * does the passed key match the key in the instance * * @param {Array&lt;*&gt;} key the key to test * @returns {boolean} does the key passed match that in the instance */ matches(key: Array&lt;Object&gt;): boolean { return this._isPropShallowEqual('props', key[0]) &amp;&amp; this._isPropShallowEqual('context', key[1]); } } export default ReactCacheKey; × Search results Close Documentation generated by JSDoc 3.5.3 using the DocStrap template. "},"Cache.js.html":{"id":"Cache.js.html","title":"Source: Cache.js","body":" moize Modules moize Classes CacheMultipleParameterCacheKeyReactCacheKeySerializedCacheKeySingleParameterCacheKey Global _isPropShallowEqualaddcleargetgetReactCacheKeygetSerializedCacheKeygetStandardCacheKeyhasmatchesPROMISE_OPTIONSREACT_OPTIONSremoveSERIALIZE_OPTIONS Source: Cache.js // @flow // types import type { ListItem } from './types'; // utils import { findIndex, findIndexAfterFirst, splice, unshift } from './utils'; /** * @class Cache * * @classdesc * class that is similar to the Map infrastructure, but faster and * more targeted to moize use cases */ class Cache { lastItem: ListItem = {}; list: Array&lt;ListItem&gt; = []; size: number = 0; /** * @function add * * @description * add a new item to cache * * @param {*} key the key to assign * @param {*} value the value to assign at key */ add(key: any, value: any): any { this.lastItem = unshift(this.list, { key, value }); this.size++; } /** * @function clear * * @description * clear the cache of all items */ clear() { this.lastItem = {}; this.list.length = this.size = 0; } expireAfter(key: any, maxAge: number) { setTimeout(() =&gt; { this.remove(key); }, maxAge); } /** * @function get * * @description * get the value of an item from cache if it exists * * @param {*} key the key to get the value of * @returns {*} the value at key */ get(key: any): any { if (!this.size) { return; } if (key === this.lastItem.key) { return this.lastItem.value; } const index: number = findIndexAfterFirst(this.list, key); if (~index) { this.lastItem = this.list[index]; return unshift(splice(this.list, index), this.lastItem).value; } } /** * @function has * * @description * does the key exist in the cache * * @param {*} key the key to find in cache * @returns {boolean} does the key exist in cache */ has(key: any): boolean { return this.size !== 0 &amp;&amp; (key === this.lastItem.key || !!~findIndexAfterFirst(this.list, key)); } /** * @function remove * * @description * remove the item at key from cach * * @param {*} key the key to remove from cache * @returns {void} */ remove(key: any) { const index: number = findIndex(this.list, key); if (~index) { splice(this.list, index); if (this.size === 1) { return this.clear(); } this.size--; if (!index) { this.lastItem = this.list[0]; } } } /** * @function update * @memberof Cache * @instance * * @description * update an item in-place with a new value * * @param {*} key key to update value of * @param {*} value value to store in the map at key */ update(key: any, value: any) { const index: number = findIndex(this.list, key); if (~index) { this.list[index].value = value; if (this.lastItem &amp;&amp; key === this.lastItem.key) { this.lastItem.value = value; } } } } export default Cache; × Search results Close Documentation generated by JSDoc 3.5.3 using the DocStrap template. "},"utils.js.html":{"id":"utils.js.html","title":"Source: utils.js","body":" moize Modules moize Classes CacheMultipleParameterCacheKeyReactCacheKeySerializedCacheKeySingleParameterCacheKey Global _isPropShallowEqualaddcleargetgetReactCacheKeygetSerializedCacheKeygetStandardCacheKeyhasmatchesPROMISE_OPTIONSREACT_OPTIONSremoveSERIALIZE_OPTIONS Source: utils.js // @flow // cache import Cache from './Cache'; // cache key import ReactCacheKey from './ReactCacheKey'; import SerializedCacheKey from './SerializedCacheKey'; import SingleParameterCacheKey from './SingleParameterCacheKey'; import MultipleParameterCacheKey from './MultipleParameterCacheKey'; // constants import { DEFAULT_OPTIONS, FINITE_POSITIVE_INTEGER, FUNCTION_NAME_REGEXP, FUNCTION_TYPEOF, GOTCHA_OBJECT_CLASSES, INVALID_PROMISE_LIBRARY_ERROR, OBJECT_TYPEOF, STATIC_PROPERTIES_TO_PASS } from './constants'; // serialize import { getSerializerFunction } from './serialize'; // types import type { ListItem, Options } from './types'; type StandardCacheKey = MultipleParameterCacheKey | StandardCacheKey; type CacheKey = ReactCacheKey | SerializedCacheKey | StandardCacheKey; /** * @private * * @function isComplexObject * * @description * is the object passed a complex object * * @param {*} object object to test if it is complex * @returns {boolean} is it a complex object */ export const isComplexObject = (object: any): boolean =&gt; { return !!object &amp;&amp; typeof object === OBJECT_TYPEOF; }; /** * @private * * @function isFiniteAndPositiveInteger * * @description * is the number passed an integer that is finite and positive * * @param {number} number number to test for finiteness and positivity * @returns {boolean} is the number finite and positive */ export const isFiniteAndPositiveInteger = (number: number): boolean =&gt; { return FINITE_POSITIVE_INTEGER.test(`${number}`); }; /** * @private * * @function isFunction * * @description * is the object passed a function or not * * @param {*} object object to test * @returns {boolean} is it a function */ export const isFunction = (object: any): boolean =&gt; { return typeof object === FUNCTION_TYPEOF; }; /** * @private * * @function isPlainObject * * @description * is the object passed a plain object or not * * @param {*} object object to test * @returns {boolean} is it a plain object */ export const isPlainObject = (object: any): boolean =&gt; { return isComplexObject(object) &amp;&amp; object.constructor === Object; }; /** * @private * * @function isValueObjectOrArray * * @description * check if the object is actually an object or array * * @param {*} object object to test * @returns {boolean} is the object an object or array */ export const isValueObjectOrArray = (object: any): boolean =&gt; { if (!isComplexObject(object)) { return false; } let index = 0; while (index &lt; GOTCHA_OBJECT_CLASSES.length) { if (object instanceof GOTCHA_OBJECT_CLASSES[index]) { return false; } index++; } return true; }; /** * @private * * @function addStaticPropertiesToFunction * * @description * add static properties to the memoized function if they exist on the original * * @param {function} originalFunction the function to be memoized * @param {function} memoizedFn the higher-order memoized function * @returns {function} memoizedFn with static properties added */ export const addStaticPropertiesToFunction = (originalFunction: Function, memoizedFn: Function): Function =&gt; { let index: number = STATIC_PROPERTIES_TO_PASS.length, property: string; while (index--) { property = STATIC_PROPERTIES_TO_PASS[index]; if (originalFunction[property]) { memoizedFn[property] = originalFunction[property]; } } return memoizedFn; }; /** * @private * * @function compose * * @description * method to compose functions and return a single function * * @param {...Array&lt;function&gt;} functions the functions to compose * @returns {function(...Array&lt;*&gt;): *} the composed function */ export const compose = (...functions: Array&lt;Function&gt;): Function =&gt; { return functions.reduce((f: Function, g: Function): Function =&gt; { return (...args: Array&lt;any&gt;): any =&gt; { return f(g(...args)); }; }); }; /** * @private * * @function createCurriableOptionMethod * * @description * create a method that will curry moize with the option + value passed * * @param {function} fn the method to call * @param {string} option the name of the option to apply * @param {*} value the value to assign to option * @returns {function} the moizer with the option pre-applied */ export const createCurriableOptionMethod = (fn: Function, option: string): Function =&gt; { return function(value: any): Function { return fn({ [option]: value }); }; }; /** * @private * * @function createFindIndex * * @description * create a findIndex method based on the startingIndex passed * * @param {number} startingIndex the index to start in the find method returned * @returns {function(Array&lt;ListItem&gt;, *): number} the findIndex method */ export const createFindIndex = (startingIndex: number): Function =&gt; { // eslint-disable-line no-use-before-define return (list: Array&lt;ListItem&gt;, key: any): number =&gt; { let index: number = startingIndex; while (index &lt; list.length) { if (key === list[index].key) { return index; } index++; } return -1; }; }; /** * @private * * @function createPluckFromInstanceList * * @description * get a property from the list on the cache * * @param {{list: Array&lt;Object&gt;}} cache cache whose list to map over * @param {string} key key to pluck from list * @returns {Array&lt;*&gt;} array of values plucked at key */ export const createPluckFromInstanceList = (cache: Cache, key: string): Function =&gt; { return (): Array&lt;any&gt; =&gt; { return cache.list.map((item: ListItem) =&gt; { return item[key]; }); }; }; /** * @private * * @function createPromiseRejecter * * @description * create method that will reject the promise and delete the key from cache * * @param {Cache} cache cache to update * @param {*} key key to delete from cache * @param {function} promiseLibrary the promise library used * @returns {function} the rejecter function for the promise */ export const createPromiseRejecter = (cache: Cache, key: any, {promiseLibrary}: Options): Function =&gt; { return (exception: Error): Promise&lt;any&gt; =&gt; { cache.remove(key); // $FlowIgnore promiseLibrary can have property methods return promiseLibrary.reject(exception); }; }; /** * @private * * @function createPromiseResolver * * @description * create method that will resolve the promise and update the key in cache * * @param {Cache} cache cache to update * @param {*} key key to update in cache * @param {boolean} hasMaxAge should the cache expire after some time * @param {number} maxAge the age after which the cache will be expired * @param {function} promiseLibrary the promise library used * @returns {function} the resolver function for the promise */ export const createPromiseResolver = ( cache: Cache, key: any, hasMaxAge: boolean, {maxAge, promiseLibrary}: Options ) =&gt; { return (resolvedValue: any): Promise&lt;any&gt; =&gt; { // $FlowIgnore promiseLibrary can have property methods cache.update(key, promiseLibrary.resolve(resolvedValue)); if (hasMaxAge) { cache.expireAfter(key, maxAge); } return resolvedValue; }; }; /** * @private * * @function findIndex * * @description * find the index of the key starting at the first index * * @param {Array&lt;ListItem&gt;} list the list to find the key in * @param {*} key the key to test against * @returns {number} the index of the matching key, or -1 */ export const findIndex: Function = createFindIndex(0); /** * @private * * @function findIndexAfterFirst * * @description * find the index of the key starting at the second index * * @param {Array&lt;ListItem&gt;} list the list to find the key in * @param {*} key the key to test against * @returns {number} the index of the matching key, or -1 */ export const findIndexAfterFirst: Function = createFindIndex(1); /** * @private * * @function getDefaultedOptions * * @description * get the options coalesced to their defaults * * @param {Object} options the options passed to the moize method * @returns {Options} the coalesced options object */ export const getDefaultedOptions = (options: Object): Options =&gt; { let coalescedOptions: Object = { ...DEFAULT_OPTIONS, ...options }; coalescedOptions.serializer = coalescedOptions.serialize ? getSerializerFunction(coalescedOptions) : null; return coalescedOptions; }; /** * @private * * @function getFunctionNameViaRegexp * * @description * use regexp match on stringified function to get the function name * * @param {function} fn function to get the name of * @returns {string} function name */ export const getFunctionNameViaRegexp = (fn: Function): string =&gt; { const match: ?Array&lt;string&gt; = fn.toString().match(FUNCTION_NAME_REGEXP); return match ? match[1] : ''; }; /** * @private * * @function getFunctionName * * @description * get the function name, either from modern property or regexp match, * falling back to generic string * * @param {function} fn function to get the name of * @returns {string} function name */ export const getFunctionName = (fn: Function): string =&gt; { return fn.displayName || fn.name || getFunctionNameViaRegexp(fn) || FUNCTION_TYPEOF; }; /** * @function getReactCacheKey * * @description * get the cache key specific to react * * @param {Cache} cache the cache to find a potential matching key in * @param {*} key the key to try to find a match of, or turn into a new ReactCacheKey * @returns {ReactCacheKey} the matching cache key, or a new one */ export const getReactCacheKey = (cache: Cache, key: Array&lt;any&gt;): ReactCacheKey =&gt; { // $FlowIgnore if cache has size, the key exists if (cache.size &amp;&amp; cache.lastItem.key.matches(key)) { // $FlowIgnore if the key matches, the key exists return cache.lastItem.key; } let index: number = 1; while (index &lt; cache.size) { // $FlowIgnore if cache has size, the key exists if (cache.list[index].key.matches(key)) { // $FlowIgnore if the key matches, the key exists return cache.list[index].key; } index++; } return new ReactCacheKey(key); }; /** * @function getSerializedCacheKey * * @description * get the cache key specific to serialized methods * * @param {Cache} cache the cache to find a potential matching key in * @param {*} key the key to try to find a match of, or turn into a new SerializedCacheKey * @param {Options} options the options passed to the moized method * @returns {SerializedCacheKey} the matching cache key, or a new one */ export const getSerializedCacheKey = (cache: Cache, key: Array&lt;any&gt;, options: Options): SerializedCacheKey =&gt; { // $FlowIgnore if cache has size, the key exists if (cache.size &amp;&amp; cache.lastItem.key.matches(key)) { // $FlowIgnore if the key matches, the key exists return cache.lastItem.key; } let index: number = 1; while (index &lt; cache.size) { // $FlowIgnore if cache has size, the key exists if (cache.list[index].key.matches(key)) { // $FlowIgnore if the key matches, the key exists return cache.list[index].key; } index++; } return new SerializedCacheKey(key, options.serializer); }; /** * @function getStandardCacheKey * * @description * get the cache key for standard parameters, either single or multiple * * @param {Cache} cache the cache to find a potential matching key in * @param {*} key the key to try to find a match of, or turn into a new Multiple / SingleParameterCacheKey * @returns {StandardCacheKey} the matching cache key, or a new one */ export const getStandardCacheKey = (cache: Cache, key: Array&lt;any&gt;): StandardCacheKey =&gt; { const isMultiParamKey: boolean = key.length &gt; 1; // $FlowIgnore if cache has size, the key exists if (cache.size &amp;&amp; cache.lastItem.key.matches(key, isMultiParamKey)) { return cache.lastItem.key; } let index: number = 1; while (index &lt; cache.size) { // $FlowIgnore if cache has size, the key exists if (cache.list[index].key.matches(key, isMultiParamKey)) { return cache.list[index].key; } index++; } return isMultiParamKey ? new MultipleParameterCacheKey(key) : new SingleParameterCacheKey(key); }; /** * @private * * @function getGetCacheKeyMethod * * @description * based on the options, get the getCacheKey method * * @param {Options} options the options passed to the moized method * @returns {function(Cache, Array&lt;*&gt;): CacheKey} the cache key */ export const getGetCacheKeyMethod = (options: Options): Function =&gt; { if (options.isReact) { return getReactCacheKey; } if (options.serialize) { return getSerializedCacheKey; } return getStandardCacheKey; }; /** * @private * * @function createGetCacheKey * * @description * create the method that will get the cache key based on the options passed to the moized method * * @param {Cache} cache the cache to get the key from * @param {Options} options the options passed to the moized method * @returns {function(*): CacheKey} the method that will get the cache key */ export const createGetCacheKey = (cache: Cache, options: Options): Function =&gt; { const hasMaxArgs: boolean = isFiniteAndPositiveInteger(options.maxArgs); const getCacheKeyMethod: Function = getGetCacheKeyMethod(options); const shouldIncludeOptions: boolean = options.serialize; if (shouldIncludeOptions) { return (key: any): CacheKey =&gt; { return getCacheKeyMethod(cache, hasMaxArgs ? key.slice(0, options.maxArgs) : key, options); }; } return (key: any): CacheKey =&gt; { return getCacheKeyMethod(cache, hasMaxArgs ? key.slice(0, options.maxArgs) : key); }; }; /** * @private * * @function createSetNewCachedValue * * @description * assign the new value to the key in the functions cache and return the value * * @param {Cache} cache the cache to assign the value to at key * @param {Options} options the options passed to the moize method * @returns {function(function, *, *): *} value just stored in cache */ export const createSetNewCachedValue = (cache: Cache, options: Options): Function =&gt; { const hasMaxAge: boolean = isFiniteAndPositiveInteger(options.maxAge); const hasMaxSize: boolean = isFiniteAndPositiveInteger(options.maxSize); const { maxAge, maxSize } = options; if (options.isPromise) { if (!isFunction(options.promiseLibrary) &amp;&amp; !isPlainObject(options.promiseLibrary)) { throw new TypeError(INVALID_PROMISE_LIBRARY_ERROR); } return (key: any, value: any): Promise&lt;any&gt; =&gt; { const promiseResolver = createPromiseResolver(cache, key, hasMaxAge, options); const promiseRejecter = createPromiseRejecter(cache, key, options); const handler = value.then(promiseResolver, promiseRejecter); cache.add(key, handler); if (hasMaxSize &amp;&amp; cache.size &gt; maxSize) { cache.remove(cache.list[cache.list.length - 1].key); } return handler; }; } return (key: any, value: any): any =&gt; { cache.add(key, value); if (hasMaxAge) { cache.expireAfter(key, maxAge); } if (hasMaxSize &amp;&amp; cache.size &gt; maxSize) { cache.remove(cache.list[cache.list.length - 1].key); } return value; }; }; /** * @private * * @function splice * * @description * faster version of splicing a single item from the array * * @param {Array&lt;*&gt;} array array to splice from * @param {number} startingIndex index to splice at * @returns {Array&lt;*&gt;} array minus the item removed */ export const splice = (array: Array&lt;any&gt;, startingIndex: number): Array&lt;any&gt; =&gt; { if (!array.length) { return array; } let index: number = startingIndex - 1; while (++index &lt; array.length) { array[index] = array[index + 1]; } array.length -= 1; return array; }; /** * @private * * @function unshift * * @description * faster version of unshifting a single item into an array * * @param {Array&lt;*&gt;} array array to unshift into * @param {*} item item to unshift into array * @returns {*} the item just added to the array */ export const unshift = (array: Array&lt;any&gt;, item: any): any =&gt; { let index: number = array.length; while (index--) { array[index + 1] = array[index]; } return array[0] = item; }; /** * @private * * @function createAddPropertiesToFunction * * @description * add the static properties to the moized function * * @param {Cache} cache the cache for the moized function * @param {function} originalFunction the function to be moized * @param {Options} options the options passed to the moize method * @returns {function(function): function} the method which will add the static properties */ export const createAddPropertiesToFunction = (cache: Cache, originalFunction: Function, options: Options) =&gt; { const getCacheKey = createGetCacheKey(cache, options); return (moizedFunction: Function): Function =&gt; { moizedFunction.cache = cache; moizedFunction.displayName = `moize(${getFunctionName(originalFunction)})`; moizedFunction.isMoized = true; moizedFunction.options = options; moizedFunction.originalFunction = originalFunction; /** * @private * * @function add * * @description * manually add an item to cache if the key does not already exist * * @param {Array&lt;any&gt;} key key to use in cache * @param {*} value value to assign to key */ moizedFunction.add = (key: Array&lt;any&gt;, value: any) =&gt; { const internalKey = getCacheKey(key); if (!cache.has(internalKey)) { cache.add(internalKey, value); } }; /** * @private * * @function clear * * @description * clear the current cache for this method */ moizedFunction.clear = cache.clear; /** * @private * * @function has * * @description * does the function have cache for the specific args passed * * @param {Array&lt;*&gt;} key combination of args to remove from cache * @returns {boolean} does the cache for the give args exist */ moizedFunction.has = (key: Array&lt;any&gt;) =&gt; { return cache.has(getCacheKey(key)); }; /** * @private * * @function keys * * @description * get the list of keys currently in cache * * @returns {Array&lt;*&gt;} */ moizedFunction.keys = createPluckFromInstanceList(cache, 'key'); /** * @private * * @function remove * * @description * remove the item from cache for the key passed for this method * * @param {Array&lt;*&gt;} key combination of args to remove from cache */ moizedFunction.remove = (key: Array&lt;any&gt;) =&gt; { cache.remove(getCacheKey(key)); }; /** * @private * * @function values * * @description * get the list of values currently in cache * * @returns {Array&lt;*&gt;} */ moizedFunction.values = createPluckFromInstanceList(cache, 'value'); return addStaticPropertiesToFunction(originalFunction, moizedFunction); }; }; × Search results Close Documentation generated by JSDoc 3.5.3 using the DocStrap template. "},"MultipleParameterCacheKey.js.html":{"id":"MultipleParameterCacheKey.js.html","title":"Source: MultipleParameterCacheKey.js","body":" moize Modules moize Classes CacheMultipleParameterCacheKeyReactCacheKeySerializedCacheKeySingleParameterCacheKey Global _isPropShallowEqualaddcleargetgetReactCacheKeygetSerializedCacheKeygetStandardCacheKeyhasmatchesPROMISE_OPTIONSREACT_OPTIONSremoveSERIALIZE_OPTIONS Source: MultipleParameterCacheKey.js // @flow /** * @class MultipleParameterCacheKey * * @classdesc * cache key used when there are multiple standard parameters */ class MultipleParameterCacheKey { constructor(key: Array&lt;any&gt;) { this.key = key; this.size = key.length; return this; } isMultiParamKey: boolean = true; key: any = null; size: number = 0; /** * @function matches * * @description * does the passed key match the key in the instance * * @param {Array&lt;*&gt;} key the key to test * @param {boolean} isMultiParamKey is the key a multi-parameter key * @returns {boolean} does the key passed match that in the instance */ matches(key: Array&lt;any&gt;, isMultiParamKey: boolean): boolean { if (!isMultiParamKey || key.length !== this.size) { return false; } let index: number = 0; while (index &lt; this.size) { if (key[index] !== this.key[index]) { return false; } index++; } return true; } } export default MultipleParameterCacheKey; × Search results Close Documentation generated by JSDoc 3.5.3 using the DocStrap template. "},"SerializedCacheKey.js.html":{"id":"SerializedCacheKey.js.html","title":"Source: SerializedCacheKey.js","body":" moize Modules moize Classes CacheMultipleParameterCacheKeyReactCacheKeySerializedCacheKeySingleParameterCacheKey Global _isPropShallowEqualaddcleargetgetReactCacheKeygetSerializedCacheKeygetStandardCacheKeyhasmatchesPROMISE_OPTIONSREACT_OPTIONSremoveSERIALIZE_OPTIONS Source: SerializedCacheKey.js // @flow // serialize import { stringify } from './serialize'; /** * @class SerializedCacheKey * * @classdesc * cache key used when the parameters should be serialized */ class SerializedCacheKey { constructor(key: Array&lt;any&gt;, serializerFunction: Function) { this.key = serializerFunction(key); this.serializer = serializerFunction; return this; } key: any = null; serializer: Function = stringify; /** * @function matches * * @description * does the passed key match the key in the instance *W * @param {Array&lt;*&gt;} key the key to test * @returns {boolean} does the key passed match that in the instance */ matches(key: Array&lt;any&gt;): boolean { return this.key === this.serializer(key); } } export default SerializedCacheKey; × Search results Close Documentation generated by JSDoc 3.5.3 using the DocStrap template. "},"SingleParameterCacheKey.js.html":{"id":"SingleParameterCacheKey.js.html","title":"Source: SingleParameterCacheKey.js","body":" moize Modules moize Classes CacheMultipleParameterCacheKeyReactCacheKeySerializedCacheKeySingleParameterCacheKey Global _isPropShallowEqualaddcleargetgetReactCacheKeygetSerializedCacheKeygetStandardCacheKeyhasmatchesPROMISE_OPTIONSREACT_OPTIONSremoveSERIALIZE_OPTIONS Source: SingleParameterCacheKey.js // @flow /** * @class SingleParameterCacheKey * * @classdesc * cache key used when there is a single standard parameter */ class SingleParameterCacheKey { constructor(key: Array&lt;any&gt;) { this.key = key[0]; return this; } isMultiParamKey: boolean = false; key: any = null; /** * @function matches * * @description * does the passed key match the key in the instance * * @param {Array&lt;*&gt;} key the key to test * @param {boolean} isMultiParamKey is the key a multi-parameter key * @returns {boolean} does the key passed match that in the instance */ matches(key: Array&lt;any&gt;, isMultiParamKey: boolean): boolean { return !isMultiParamKey &amp;&amp; key[0] === this.key; } } export default SingleParameterCacheKey; × Search results Close Documentation generated by JSDoc 3.5.3 using the DocStrap template. "},"index.js.html":{"id":"index.js.html","title":"Source: index.js","body":" moize Modules moize Classes CacheMultipleParameterCacheKeyReactCacheKeySerializedCacheKeySingleParameterCacheKey Global _isPropShallowEqualaddcleargetgetReactCacheKeygetSerializedCacheKeygetStandardCacheKeyhasmatchesPROMISE_OPTIONSREACT_OPTIONSremoveSERIALIZE_OPTIONS Source: index.js // @flow // cache import Cache from './Cache'; // constants import { INVALID_FIRST_PARAMETER_ERROR, PROMISE_OPTIONS, REACT_OPTIONS, SERIALIZE_OPTIONS } from './constants'; // types import type { Options } from './types'; // utils import { compose, createAddPropertiesToFunction, createCurriableOptionMethod, createGetCacheKey, createSetNewCachedValue, getDefaultedOptions, isFunction, isPlainObject } from './utils'; /** * @module moize */ /** * @function moize * * @description * store cached values returned from calling method with arguments to avoid reprocessing data from same arguments * * @example * import moize from 'moize'; * * // standard implementation * const fn = (foo, bar) =&gt; { * return `${foo} ${bar}`; * }; * const memoizedFn = moize(fn); * * // implementation with options * const fn = async (id) =&gt; { * return get(`http://foo.com/${id}`); * }; * const memoizedFn = moize(fn, { * isPromise: true, * maxSize: 5 * }); * * @param {function} functionOrComposableOptions method to memoize * @param {Options} [passedOptions={}] options to customize how the caching is handled * @param {boolean} [passedOptions.isPromise=false] is the function return expected to be a promise to resolve * @param {number} [passedOptions.maxAge=Infinity] the maximum age the value should persist in cache * @param {number} [passedOptions.maxArgs=Infinity] the maximum number of arguments to be used in serializing the keys * @param {number} [passedOptions.maxSize=Infinity] the maximum size of the cache to retain * @param {function} [passedOptions.promiseLibrary=Promise] promise library to use for resolution / rejection * @param {function} [passedOptions.serializeFunctions=false] should function parameters be serialized as well * @param {function} [passedOptions.serializer] method to serialize arguments with for cache storage * @returns {Function} higher-order function which either returns from cache or newly-computed value */ const moize: Function = (functionOrComposableOptions: (Function|Options), passedOptions: Object = {}): Function =&gt; { if (isPlainObject(functionOrComposableOptions)) { return function(fn: Function, otherOptions: Object = {}): Function { return moize(fn, { // $FlowIgnore functionOrComposableOptions is object of options ...functionOrComposableOptions, ...otherOptions }); }; } if (!isFunction(functionOrComposableOptions)) { throw new TypeError(INVALID_FIRST_PARAMETER_ERROR); } // $FlowIgnore if the function is already moized, it has an isMoized property on it const isComposed: boolean = functionOrComposableOptions.isMoized; // $FlowIgnore if the function is already moized, it has an originalFunction property on it const fn: Function = isComposed ? functionOrComposableOptions.originalFunction : functionOrComposableOptions; const options: Options = getDefaultedOptions(!isComposed ? passedOptions : { // $FlowIgnore if the function is already moized, it has an options property on it ...functionOrComposableOptions.options, ...passedOptions }); const cache: Cache = new Cache(); const addPropertiesToFunction: Function = createAddPropertiesToFunction(cache, fn, options); const getCacheKey: Function = createGetCacheKey(cache, options); const setNewCachedValue: Function = createSetNewCachedValue(cache, options); const moizedFunction: Function = function(...args: Array&lt;any&gt;): any { const key: any = getCacheKey(args); return cache.size &amp;&amp; cache.has(key) ? cache.get(key) : setNewCachedValue(key, fn.apply(this, args)); }; return addPropertiesToFunction(moizedFunction); }; moize.compose = compose; moize.maxAge = createCurriableOptionMethod(moize, 'maxAge'); moize.maxArgs = createCurriableOptionMethod(moize, 'maxArgs'); moize.maxSize = createCurriableOptionMethod(moize, 'maxSize'); moize.promise = moize(PROMISE_OPTIONS); moize.react = moize(REACT_OPTIONS); moize.reactSimple = compose(moize.react, moize.maxSize(1)); moize.serialize = moize(SERIALIZE_OPTIONS); moize.simple = moize.maxSize(1); export default moize; × Search results Close Documentation generated by JSDoc 3.5.3 using the DocStrap template. "},"constants.js.html":{"id":"constants.js.html","title":"Source: constants.js","body":" moize Modules moize Classes CacheMultipleParameterCacheKeyReactCacheKeySerializedCacheKeySingleParameterCacheKey Global _isPropShallowEqualaddcleargetgetReactCacheKeygetSerializedCacheKeygetStandardCacheKeyhasmatchesPROMISE_OPTIONSREACT_OPTIONSremoveSERIALIZE_OPTIONS Source: constants.js // @flow /** * @private * * @constant {RegExp} FINITE_POSITIVE_INTEGER */ export const FINITE_POSITIVE_INTEGER: RegExp = /^[1-9]\\d*$/; /** * @private * * @constant {RegExp} FUNCTION_NAME_REGEXP */ export const FUNCTION_NAME_REGEXP: RegExp = /^\\s*function\\s+([^\\(\\s]*)\\s*/; /** * @private * * @constant {string} FUNCTION_TYPEOF * @default */ export const FUNCTION_TYPEOF: string = 'function'; /** * @private * * @constant {Array&lt;Object&gt;} GOTCHA_OBJECT_CLASSES */ export const GOTCHA_OBJECT_CLASSES: Array&lt;Object&gt; = [ Boolean, Date, Number, RegExp, String ]; /** * @private * * @constant {number} INFINITY * @default */ export const INFINITY: number = Number.POSITIVE_INFINITY; /** * @private * * @constant {string} INVALID_FIRST_PARAMETER_ERROR * @default */ export const INVALID_FIRST_PARAMETER_ERROR: string = 'You must pass either a function or an object of options as the first parameter to moize.'; /** * @private * * @constant {string} INVALID_PROMISE_LIBRARY_ERROR * @default */ export const INVALID_PROMISE_LIBRARY_ERROR: string = 'The promiseLibrary passed must either be a function or an object with the resolve / reject methods.'; /** * @private * * @constant {function|undefined} NATIVE_PROMISE */ export const NATIVE_PROMISE: ?Function = typeof Promise === FUNCTION_TYPEOF ? Promise : undefined; /** * @private * * @constant {Object} DEFAULT_OPTIONS */ export const DEFAULT_OPTIONS: Object = { isPromise: false, isReact: false, maxAge: INFINITY, maxArgs: INFINITY, maxSize: INFINITY, promiseLibrary: NATIVE_PROMISE, serialize: false, serializeFunctions: false }; /** * @private * * @constant {string} OBJECT_TYPEOF * @default */ export const OBJECT_TYPEOF: string = 'object'; /** * @private * * @constant {Array&lt;string&gt;} STATIC_PROPERTIES_TO_PASS */ export const STATIC_PROPERTIES_TO_PASS: Array&lt;string&gt; = [ 'contextTypes', 'defaultProps', 'propTypes' ]; /** * @constant {{isPromise: true}} PROMISE_OPTIONS */ export const PROMISE_OPTIONS = { isPromise: true }; /** * @constant {{maxArgs: number, serialize: boolean, serializeFunctions: boolean}} REACT_OPTIONS */ export const REACT_OPTIONS = { isReact: true }; /** * @constant {{serialize: boolean}} SERIALIZE_OPTIONS */ export const SERIALIZE_OPTIONS = { serialize: true }; × Search results Close Documentation generated by JSDoc 3.5.3 using the DocStrap template. "},"global.html":{"id":"global.html","title":"Global","body":" moize Modules moize Classes CacheMultipleParameterCacheKeyReactCacheKeySerializedCacheKeySingleParameterCacheKey Global _isPropShallowEqualaddcleargetgetReactCacheKeygetSerializedCacheKeygetStandardCacheKeyhasmatchesPROMISE_OPTIONSREACT_OPTIONSremoveSERIALIZE_OPTIONS Global Members &lt;constant&gt; PROMISE_OPTIONS :Object Type: Object Source: constants.js, line 93 &lt;constant&gt; REACT_OPTIONS :Object Type: Object Source: constants.js, line 100 &lt;constant&gt; SERIALIZE_OPTIONS :Object Type: Object Source: constants.js, line 107 Methods _isPropShallowEqual(prop, object) check if the prop value passed is equal to the key's value Parameters: Name Type Description prop string the key property to test object Object the value of the key to test against Source: ReactCacheKey.js, line 32 Returns: is the prop value shallow equal to the object Type boolean add(key, value) add a new item to cache Parameters: Name Type Description key * the key to assign value * the value to assign at key Source: Cache.js, line 31 clear() clear the cache of all items Source: Cache.js, line 49 get(key) get the value of an item from cache if it exists Parameters: Name Type Description key * the key to get the value of Source: Cache.js, line 70 Returns: the value at key Type * getReactCacheKey(cache, key) get the cache key specific to react Parameters: Name Type Description cache Cache the cache to find a potential matching key in key * the key to try to find a match of, or turn into a new ReactCacheKey Source: utils.js, line 394 Returns: the matching cache key, or a new one Type ReactCacheKey getSerializedCacheKey(cache, key, options) get the cache key specific to serialized methods Parameters: Name Type Description cache Cache the cache to find a potential matching key in key * the key to try to find a match of, or turn into a new SerializedCacheKey options Options the options passed to the moized method Source: utils.js, line 426 Returns: the matching cache key, or a new one Type SerializedCacheKey getStandardCacheKey(cache, key) get the cache key for standard parameters, either single or multiple Parameters: Name Type Description cache Cache the cache to find a potential matching key in key * the key to try to find a match of, or turn into a new Multiple / SingleParameterCacheKey Source: utils.js, line 459 Returns: the matching cache key, or a new one Type StandardCacheKey has(key) does the key exist in the cache Parameters: Name Type Description key * the key to find in cache Source: Cache.js, line 99 Returns: does the key exist in cache Type boolean matches(key, isMultiParamKey) does the passed key match the key in the instance Parameters: Name Type Description key Array.&lt;*&gt; the key to test isMultiParamKey boolean is the key a multi-parameter key Source: MultipleParameterCacheKey.js, line 27 Returns: does the key passed match that in the instance Type boolean matches(key) does the passed key match the key in the instance Parameters: Name Type Description key Array.&lt;*&gt; the key to test Source: ReactCacheKey.js, line 62 Returns: does the key passed match that in the instance Type boolean matches(key) does the passed key match the key in the instance W Parameters: Name Type Description key Array.&lt;*&gt; the key to test Source: SerializedCacheKey.js, line 31 Returns: does the key passed match that in the instance Type boolean matches(key, isMultiParamKey) does the passed key match the key in the instance Parameters: Name Type Description key Array.&lt;*&gt; the key to test isMultiParamKey boolean is the key a multi-parameter key Source: SingleParameterCacheKey.js, line 25 Returns: does the key passed match that in the instance Type boolean remove(key) remove the item at key from cach Parameters: Name Type Description key * the key to remove from cache Source: Cache.js, line 114 Returns: Type void × Search results Close Documentation generated by JSDoc 3.5.3 using the DocStrap template. "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" moize Modules moize Classes CacheMultipleParameterCacheKeyReactCacheKeySerializedCacheKeySingleParameterCacheKey Global _isPropShallowEqualaddcleargetgetReactCacheKeygetSerializedCacheKeygetStandardCacheKeyhasmatchesPROMISE_OPTIONSREACT_OPTIONSremoveSERIALIZE_OPTIONS Modules Classes Cache MultipleParameterCacheKey ReactCacheKey SerializedCacheKey SingleParameterCacheKey × Search results Close Documentation generated by JSDoc 3.5.3 using the DocStrap template. "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" moize Modules moize Classes CacheMultipleParameterCacheKeyReactCacheKeySerializedCacheKeySingleParameterCacheKey Global _isPropShallowEqualaddcleargetgetReactCacheKeygetSerializedCacheKeygetStandardCacheKeyhasmatchesPROMISE_OPTIONSREACT_OPTIONSremoveSERIALIZE_OPTIONS Classes Classes Cache MultipleParameterCacheKey ReactCacheKey SerializedCacheKey SingleParameterCacheKey × Search results Close Documentation generated by JSDoc 3.5.3 using the DocStrap template. "},"index.html":{"id":"index.html","title":"Index","body":" moize Modules moize Classes CacheMultipleParameterCacheKeyReactCacheKeySerializedCacheKeySingleParameterCacheKey Global _isPropShallowEqualaddcleargetgetReactCacheKeygetSerializedCacheKeygetStandardCacheKeyhasmatchesPROMISE_OPTIONSREACT_OPTIONSremoveSERIALIZE_OPTIONS moize 3.0.0 moize moize is a blazing fast memoization library for JavaScript. It handles multiple arguments out of the box (including default values), and offers options to help satisfy a number of implementation-specific needs. It has no dependencies, and is ~3kb when minified and gzipped. Table of contents Upgrade notification Installation Usage Advanced usage isPromise isReact maxAge maxArgs maxSize promiseLibrary serialize serializeFunctions serializer Usage with shortcut methods moize.maxAge moize.maxArgs moize.maxSize moize.promise moize.react moize.reactSimple moize.serialize moize.simple Composition Benchmarks Direct cache manipulation add clear has keys remove values Browser support Development Upgrade notification Users of moize 1.x.x may have experience breaking changes, especially if using a custom cache or using moize.react in a mutative way. Please see the changelog for more details about how to manage the upgrade. Installation $ npm i moize --saveUsage import moize from 'moize'; const method = (a, b) =&gt; { return a + b; }; const memoized = moize(method); memoized(2, 4); // 6 memoized(2, 4); // 6, pulled from cacheAll parameter types are supported, including circular objects, functions, etc. There are also a number of shortcut methods to easily create memoization for targeted use-cases. You can even memoize functional React components based on their props + context combination (See Usage with shortcut methods)! Advanced usage moize optionally accepts an object of options as the second parameter. The full shape of these options: { isPromise: boolean, // is the result a promise isReact: boolean, // is the result a React component maxAge: number, // amount of time in milliseconds before the cache will expire maxArgs: number, // maximum number of arguments to use as key for caching maxSize: number, // maximum size of cache for this method promiseLibrary: Function|Object, // promise library to use when isPromise is true, if not using native promises serialize: boolean, // should the parameters be serialized instead of directly referenced serializeFunctions: boolean, // should functions be included in the serialization of multiple parameters serializer: Function // method to serialize the arguments to build a unique cache key }isPromise defaults to false Is the computed value in the function a Promise, and should we cache the resolved value from that Promise. This is also available via the shortcut method of moize.promise. const fn = async (item) =&gt; { return await item; }; const memoized = moize(fn, { isPromise: true });The resolved value of the Promise will be stored in cache as a Promise itself, so that cached returns will always be in the form of a Promise. For common usage reasons, if the Promise is rejected, the cache entry will be deleted. Also, if a maxAge is provided, the countdown of that TTL will begin upon the resolution of the promise rather than at the instantiation of it. isReact defaults to false Is the function passed a stateless functional React component. This is also available via the shortcut method of moize.react. const Foo = ({bar, baz}) =&gt; { return ( &lt;div&gt; {bar}: {baz} &lt;/div&gt; ); }; export default moize(Foo, { isReact: true });The method will do a shallow comparison of both props and context of the component based on strict equality. If you want to mimic the PureComponent optimization, add the parameter maxSize set to 1. maxAge defaults to Infinity The maximum amount of time in milliseconds that you want a computed value to be stored in cache for this method. This is also available via the shortcut method of moize.maxAge. const fn = (item) =&gt; { return item; }; const memoized = moize(fn, { maxAge: 1000 * 60 * 5 // five minutes });maxArgs defaults to the length of arguments passed to the method The maximum number of arguments used in creating the key for the cache. const fn = (item1, item2, item3) =&gt; { return item1 + item2 + item3; }; const memoized = moize(fn, { maxArgs: 2 });maxSize defaults to Infinity The maximum size of the cache you want stored in cache for this method. Clearance of the cache once the maxSize is reached is on a Least Recently Used basis. This is also available via the shortcut method of moize.maxSize. const fn = (item) =&gt; { return item; }; const memoized = moize(fn, { maxSize: 5 });promiseLibrary defaults to native Promise The promise library to use for resolution / rejection of promises. const fn = (foo) =&gt; { return new Bluebird((resolve) =&gt; { resolve(foo); }); }; const memoized = moize(fn, { isPromise: true, promiseLibrary: Bluebird });Please note that for this option to work isPromise must be set to true. You can use any library where the following aspects of the specification are included: It is thenable (the generated promise has a .then() function) The Promise object itself has .resolve() and .reject() functions on it Most modern libraries (bluebird, q, etc.) include these by default, however if you are using a custom library that does not meet these requirements then you will need to implement them yourself. An example of a wrapper that creates the .resolve() and .reject() methods: import foo from 'my-promise-library'; // create a wrapper so as not to touch the library itself const customPromise = (fn) =&gt; { return foo(fn); }; // lets pretend foo has a .result() method that has the first // parameter as successful, second as failure customPromise.resolve = function(value) { return foo.result(value); }; customPromise.reject = function(error) { return foo.result(undefined, error); }; const fn = (foo) =&gt; { return customPromise((resolve) =&gt; { resolve(foo); }); }; const memoized = moize(fn, { isPromise: true, promiseLibrary: customPromise });serialize defaults to false In moize 1.x.x, parameter serialization was used, whereas in 2.x.x and beyond we use strict equality to compare parameters. While this is both faster and more accurate, there may be scenarios where you want to serialize the parameters instead (for value equality comparison in situations where you are using mutated objects, for example). Simply pass the serialize parameter as true and you will use the performant serializer from 1.x.x. This is also available via the shortcut method of moize.serialize. const fn = (mutableObject) =&gt; { return mutableObject.foo; }; const memoized = moize(fn, { serialize: true }); const object = { foo: 'foo' }; memoized(object); // 'foo' object.foo = 'bar'; memoized(object); // 'bar'serializeFunctions defaults to false By setting this option to true, a custom replacer will be used to ensure functions are included in the key serialization. This is especially beneficial when caching functional React components, as interactivity functions as part of props will now be included in the unique key structure (in fact, this is exactly how moize.react works). Please note that this will decrease performance of this specific function between 10-25% depending on environment. const FunctionalComponent = ({onClickFoo}) =&gt; { return ( &lt;button onClick={onClickFoo} type=&quot;button&quot; &gt; Click me! &lt;/button&gt; ) }; const MemoizedFunctionalComponent = moize(FunctionalComponent, { serialize: true, serializeFunctions: true });Please note that you must also set serialize to true for this setting to take effect. serializer defaults to serializeArguments in utils.js The default seralizer method is highly performant, and covers a number of edge cases (recursive objects, for example), however if you want to provide a custom one you may. The value returned from the function must be a valid value of keys for a Map. const serializer = (args) =&gt; { return JSON.stringify(args[0]); }; const memoized = moize(fn, { serialize: true, serializer });Please note that you must also set serialize to true for this setting to take effect. Usage with shortcut methods moize.maxAge Pre-applies the maxAge option as a curriable method. import moize from 'moize'; const foo = (bar, baz) =&gt; { return `${bar} ${baz}`; }; export default moize.maxAge(5000)(foo);moize.maxArgs Pre-applies the maxArgs option as a curriable method. import moize from 'moize'; const foo = (bar, baz) =&gt; { return `${bar} ${baz}`; }; export default moize.maxArgs(1)(foo);moize.maxSize Pre-applies the maxSize option as a curriable method. import moize from 'moize'; const foo = (bar, baz) =&gt; { return `${bar} ${baz}`; }; export default moize.maxSize(5)(foo);moize.promise Pre-applies the isPromise option. import moize from 'moize'; const foo = async (bar, baz) =&gt; { return await someApiCall(bar, baz); }; export default moize.promise(foo);moize.react Shortcut for memoizing functional components in React. This uses a special cache key that will do a shallow equal comparison of changes to both props and context. import moize from 'moize'; const Foo = ({bar, baz}) =&gt; { return ( &lt;div&gt; {bar} {baz} &lt;/div&gt; ); }; export default moize.react(Foo);Also, it should be noted that in usages that involve a lot of variety in the parameter changes, this has the potential for memory leaks (as the default is to retain the history of all elements). If you expect the parameters to change more than a few times, or if you are reusing the component in several places, it is recommended to apply a maxSize, or you can use the new shortcut method moize.reactSimple, which automatically sets the maxSize to 1 to mimic the PureComponent optimization. moize.reactSimple Shortcut for memoizing functional components in React, with the cache size limited to a single entry. This mimics the PureComponnt optimization, where the component will only be re-rendered on change to props or context, and the only element cached is the most recent. import moize from 'moize'; const Foo = ({bar, baz}) =&gt; { return ( &lt;div&gt; {bar} {baz} &lt;/div&gt; ); }; export default moize.reactSimple(Foo);Please note moize.reactSimple will not operate with components made via the class instantiation, as they do not offer the same referential transparency. moize.serialize Pre-applies the serialize option. import moize from 'moize'; const foo = (bar, baz) =&gt; { return `${bar} ${baz}`; }; export default moize.serialize(foo);moize.simple Pre-applies the maxSize option with 1. import moize from 'moize'; const foo = (bar, baz) =&gt; { return `${bar} ${baz}`; }; export default moize.simple(foo);Composition Starting with version 2.3.0, you can compose moize methods. This will create a new memoized method with the original function that shallowly merges the options of the two setups. Example: import moize from 'moize'; const Foo = (props) =&gt; { return ( &lt;div {...props}/&gt; ); }; // memoizing with react, as since 2.0.0 const MemoizedFoo = moize.react(Foo); // creating a separately-memoized method that has maxSize of 1 const SimpleMemoizedFoo = moize.simple(MemoizedFoo);You can also create an options-first curriable version of memoize if you just pass the options: import moize from 'moize'; // creates a function that will memoize what is passed const limitedSerializedMoize = moize({ maxSize: 5, serialize: true }); const foo = (bird) =&gt; { return `${bird} is the word`; }; const moizedFoo = limitedSerializedMoize(foo);You can also combine all of these options with moize.compose to create moize wrappers with pre-defined options. import moize from 'moize'; // creates a moizer that will have the options of // {maxAge: 5000, maxSize: 1, serialize: true, serializeFunctions: true} const superLimitedReactMoize = moize.compose(moize.react, moize.maxSize(5), moize.maxAge(5000));Benchmarks All values provided are the number of operations per second (ops/sec) calculated by the Benchmark suite. Note that underscore, lodash, and ramda do not support mulitple-parameter memoization, so they are not included in those benchmarks. Each benchmark was performed using the default configuration of the library, with a fibonacci calculation based on a starting parameter of 35, and in the case of multiple parameters a second parameter (boolean for primitives, object for complex objects) was used. underscore lodash ramda memoizee fast-memoize addy-osmani memoizerific moize 9,393,399 9,679,995 1,102,656 11,651,361 31,085,245 3,656,676 2,184,221 47,089,212 memoizee fast-memoize addy-osmani memoizerific moize 8,144,578 1,256,879 1,788,762 1,433,723 9,762,395 memoizee fast-memoize addy-osmani memoizerific moize 8,208,516 1,019,949 922,261 1,419,771 9,741,543 Direct cache manipulation There are a couple of methods provided on the memoized function which allow for programmatic manipulation of the cache: add(key, value) This will manually add the value at key in cache if key does not already exist. key is an Array of values, meant to reflect the arguments passed to the method. // single parameter is straightforward const memoized = moize((item) =&gt; { return item; }); memoized.add(['foo'], 'bar'); // pulls from cache memoized('foo');clear() This will clear all values in the cache, resetting it to a default state. const memoized = moize((item) =&gt; { return item; }); memoized.clear();has(key) This will return true if a cache entry exists for the args passed, else will return false. key is an Array of values, meant to reflect the arguments passed to the method. const memoized = moize((first, second) =&gt; { return [first, second]; }); memoized('foo', 'bar'); console.log(memoized.has(['foo', 'bar'])); // true console.log(memoized.has(['bar', 'baz'])); // falsekeys() This will return a list of the current keys in cache. const memoized = moize((item) =&gt; { return item; }); const foo = 'foo'; memoized(foo); const bar = { baz: 'baz' }; memoized(bar); const keys = memoized.keys(); // ['foo', {baz: 'baz'}]remove(key) This will remove the provided key from cache. key is an Array of values, meant to reflect the arguments passed to the method. const memoized = moize((item) =&gt; { return item; }); const foo = { bar: 'baz' }; memoized(foo); memoized.remove([foo]); // will re-execute, as it is no longer in cache memoized(foo);values() This will return a list of the current values in cache when the native Cache. const memoized = moize((item) =&gt; { return { item }; }); const foo = 'foo'; memoized(foo); const bar = { baz: 'baz' }; memoized(bar); const values = memoized.values(); // [{item: 'foo'}, {item: {baz: 'baz'}}]Browser support Chrome (all versions) Firefox (all versions) Opera 15+ Edge (all versions) IE 9+ Safari 6+ Theoretically the support should go back even farther, these are just the environments that I have tested. Development Standard stuff, clone the repo and npm install dependencies. The npm scripts available: build =&gt; run webpack to build development dist file with NODE_ENV=development build:minifed =&gt; run webpack to build production dist file with NODE_ENV=production dev =&gt; run webpack dev server to run example app (playground!) dist =&gt; runs build and build-minified docs =&gt; builds the docs via jsdoc lint =&gt; run ESLint against all files in the src folder prepublish =&gt; runs compile-for-publish prepublish:compile =&gt; run lint, test, transpile, dist test =&gt; run AVA test functions with NODE_ENV=test test:coverage =&gt; run test but with nyc for coverage checker test:watch =&gt; run test, but with persistent watcher transpile =&gt; run babel against all files in src to create files in lib × Search results Close Documentation generated by JSDoc 3.5.3 using the DocStrap template. "},"Cache.html":{"id":"Cache.html","title":"Class: Cache","body":" moize Modules moize Classes CacheMultipleParameterCacheKeyReactCacheKeySerializedCacheKeySingleParameterCacheKey Global _isPropShallowEqualaddcleargetgetReactCacheKeygetSerializedCacheKeygetStandardCacheKeyhasmatchesPROMISE_OPTIONSREACT_OPTIONSremoveSERIALIZE_OPTIONS Class: Cache Cache class that is similar to the Map infrastructure, but faster and more targeted to moize use cases new Cache() Source: Cache.js, line 12 Methods update(key, value) update an item in-place with a new value Parameters: Name Type Description key * key to update value of value * value to store in the map at key Source: Cache.js, line 143 × Search results Close Documentation generated by JSDoc 3.5.3 using the DocStrap template. "},"module-moize.html":{"id":"module-moize.html","title":"Module: moize","body":" moize Modules moize Classes CacheMultipleParameterCacheKeyReactCacheKeySerializedCacheKeySingleParameterCacheKey Global _isPropShallowEqualaddcleargetgetReactCacheKeygetSerializedCacheKeygetStandardCacheKeyhasmatchesPROMISE_OPTIONSREACT_OPTIONSremoveSERIALIZE_OPTIONS Module: moize Source: index.js, line 29 Methods &lt;inner&gt; moize(functionOrComposableOptions [, passedOptions]) store cached values returned from calling method with arguments to avoid reprocessing data from same arguments Parameters: Name Type Argument Default Description functionOrComposableOptions function method to memoize passedOptions Options &lt;optional&gt; {} options to customize how the caching is handled Properties Name Type Argument Default Description isPromise boolean &lt;optional&gt; false is the function return expected to be a promise to resolve maxAge number &lt;optional&gt; Infinity the maximum age the value should persist in cache maxArgs number &lt;optional&gt; Infinity the maximum number of arguments to be used in serializing the keys maxSize number &lt;optional&gt; Infinity the maximum size of the cache to retain promiseLibrary function &lt;optional&gt; Promise promise library to use for resolution / rejection serializeFunctions function &lt;optional&gt; false should function parameters be serialized as well serializer function &lt;optional&gt; method to serialize arguments with for cache storage Source: index.js, line 33 Returns: higher-order function which either returns from cache or newly-computed value Type function Example import moize from 'moize'; // standard implementation const fn = (foo, bar) =&gt; { return `${foo} ${bar}`; }; const memoizedFn = moize(fn); // implementation with options const fn = async (id) =&gt; { return get(`http://foo.com/${id}`); }; const memoizedFn = moize(fn, { isPromise: true, maxSize: 5 }); × Search results Close Documentation generated by JSDoc 3.5.3 using the DocStrap template. "},"MultipleParameterCacheKey.html":{"id":"MultipleParameterCacheKey.html","title":"Class: MultipleParameterCacheKey","body":" moize Modules moize Classes CacheMultipleParameterCacheKeyReactCacheKeySerializedCacheKeySingleParameterCacheKey Global _isPropShallowEqualaddcleargetgetReactCacheKeygetSerializedCacheKeygetStandardCacheKeyhasmatchesPROMISE_OPTIONSREACT_OPTIONSremoveSERIALIZE_OPTIONS Class: MultipleParameterCacheKey MultipleParameterCacheKey cache key used when there are multiple standard parameters new MultipleParameterCacheKey() Source: MultipleParameterCacheKey.js, line 7 × Search results Close Documentation generated by JSDoc 3.5.3 using the DocStrap template. "},"ReactCacheKey.html":{"id":"ReactCacheKey.html","title":"Class: ReactCacheKey","body":" moize Modules moize Classes CacheMultipleParameterCacheKeyReactCacheKeySerializedCacheKeySingleParameterCacheKey Global _isPropShallowEqualaddcleargetgetReactCacheKeygetSerializedCacheKeygetStandardCacheKeyhasmatchesPROMISE_OPTIONSREACT_OPTIONSremoveSERIALIZE_OPTIONS Class: ReactCacheKey ReactCacheKey cache key used specifically for react components new ReactCacheKey() Source: ReactCacheKey.js, line 7 × Search results Close Documentation generated by JSDoc 3.5.3 using the DocStrap template. "},"SerializedCacheKey.html":{"id":"SerializedCacheKey.html","title":"Class: SerializedCacheKey","body":" moize Modules moize Classes CacheMultipleParameterCacheKeyReactCacheKeySerializedCacheKeySingleParameterCacheKey Global _isPropShallowEqualaddcleargetgetReactCacheKeygetSerializedCacheKeygetStandardCacheKeyhasmatchesPROMISE_OPTIONSREACT_OPTIONSremoveSERIALIZE_OPTIONS Class: SerializedCacheKey SerializedCacheKey cache key used when the parameters should be serialized new SerializedCacheKey() Source: SerializedCacheKey.js, line 12 × Search results Close Documentation generated by JSDoc 3.5.3 using the DocStrap template. "},"SingleParameterCacheKey.html":{"id":"SingleParameterCacheKey.html","title":"Class: SingleParameterCacheKey","body":" moize Modules moize Classes CacheMultipleParameterCacheKeyReactCacheKeySerializedCacheKeySingleParameterCacheKey Global _isPropShallowEqualaddcleargetgetReactCacheKeygetSerializedCacheKeygetStandardCacheKeyhasmatchesPROMISE_OPTIONSREACT_OPTIONSremoveSERIALIZE_OPTIONS Class: SingleParameterCacheKey SingleParameterCacheKey cache key used when there is a single standard parameter new SingleParameterCacheKey() Source: SingleParameterCacheKey.js, line 7 × Search results Close Documentation generated by JSDoc 3.5.3 using the DocStrap template. "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
