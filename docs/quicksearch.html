<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"index.js.html":{"id":"index.js.html","title":"Source: index.js","body":" moize Modules moize Source: index.js // @flow // external dependencies import memoize from 'micro-memoize'; // constants import {DEFAULT_OPTIONS} from './constants'; // instance import {augmentMoizeInstance} from './instance'; // max age import {getMaxAgeOptions} from './maxAge'; // options import {createOnCacheOperation, getIsEqual, getIsMatchingKey, getTransformKey} from './options'; // stats import {collectStats, getDefaultProfileName, getStats, getStatsOptions, statsCache} from './stats'; // types import type {Expiration, MicroMemoizeOptions, Options} from './types'; // utils import {combine, compose, mergeOptions} from './utils'; /** * @module moize */ export {collectStats}; /** * @function moize * * @description * memoize a function based its arguments passed, potentially improving runtime performance * * @example * import moize from 'moize'; * * // standard implementation * const fn = (foo, bar) =&gt; `${foo} ${bar}`; * const memoizedFn = moize(fn); * * // implementation with options * const fn = async (id) =&gt; get(`http://foo.com/${id}`); * const memoizedFn = moize(fn, {isPromise: true, maxSize: 5}); * * // implementation with convenience methods * const Foo = ({foo}) =&gt; &lt;div&gt;{foo}&lt;/div&gt;; * const MemoizedFoo = moize.react(Foo); * * @param {function|Options} fn the function to memoized, or a list of options when currying * @param {Options} [options=DEFAULT_OPTIONS] the options to apply * @returns {function} the memoized function */ function moize(fn: Function | Options, options: Options = DEFAULT_OPTIONS): Function { if (fn.isMoized) { // $FlowIgnore if moized, originalFunction and options exist return moize(fn.originalFunction, mergeOptions(fn.options, options)); } if (typeof fn === 'object') { return (curriedFn: Function | Options, curriedOptions: Options = {}) =&gt; { return typeof curriedFn === 'function' ? // $FlowIgnore fn is actually an object of options moize(curriedFn, mergeOptions(fn, curriedOptions)) : // $FlowIgnore fn is actually an object of options moize(mergeOptions(fn, curriedFn)); }; } const coalescedOptions: Options = Object.assign({}, DEFAULT_OPTIONS, options, { profileName: options.profileName || getDefaultProfileName(fn) }); const expirations: Array&lt;Expiration&gt; = []; const { equals: equalsIgnored, isDeepEqual: isDeepEqualIgnored, isPromise, isReact: isReactIgnored, isSerialized: isSerialzedIgnored, matchesKey: matchesKeyIgnored, maxAge: maxAgeIgnored, maxArgs: maxArgsIgnored, maxSize, onCacheAdd, onCacheChange, onCacheHit, onExpire: onExpireIgnored, profileName: profileNameIgnored, shouldSerializeFunctions: shouldSerializeFunctionsIgnored, serializer: serializerIgnored, transformArgs: transformArgsIgnored, updateExpire: updateExpireIgnored, ...customOptions } = coalescedOptions; const isEqual: Function = getIsEqual(coalescedOptions); const isMatchingKey: ?Function = getIsMatchingKey(coalescedOptions); const maxAgeOptions: Options = getMaxAgeOptions(expirations, coalescedOptions, isEqual, isMatchingKey); const statsOptions: Options = getStatsOptions(coalescedOptions); const transformKey: ?Function = getTransformKey(coalescedOptions); const microMemoizeOptions: MicroMemoizeOptions = Object.assign({}, customOptions, { isEqual, isMatchingKey, isPromise, maxSize, onCacheAdd: createOnCacheOperation(combine(onCacheAdd, maxAgeOptions.onCacheAdd, statsOptions.onCacheAdd)), onCacheChange: createOnCacheOperation(onCacheChange), onCacheHit: createOnCacheOperation(combine(onCacheHit, maxAgeOptions.onCacheHit, statsOptions.onCacheHit)), transformKey }); return augmentMoizeInstance(memoize(fn, microMemoizeOptions), { expirations, options: coalescedOptions, originalFunction: fn }); } Object.assign(moize, { /** * @function * @name collectStats * @memberof module:moize * @alias moize.collectStats * * @description * start collecting statistics */ collectStats, /** * @function * @name compose * @memberof module:moize * @alias moize.compose * * @description * method to compose moized methods and return a single moized function * * @param {...Array&lt;(function)&gt;} functions the functions to compose * @returns {function(...Array&lt;*&gt;): *} the composed function */ compose(): Function { return compose.apply(null, arguments) || moize; }, /** * @function * @name deep * @memberof module:moize * @alias moize.deep * * @description * should deep equality check be used * * @returns {function} the moizer function */ deep: moize({isDeepEqual: true}), /** * @function * @name getStats * @memberof module:moize * @alias moize.getStats * * @description * get the statistics of a given profile, or overall usage * * @returns {StatsProfile} statistics for a given profile or overall usage */ getStats, /** * @function * @name isCollectingStats * @memberof module:moize * @alias moize.isCollectingStats * * @description * are stats being collected * * @returns {boolean} are stats being collected */ isCollectingStats(): boolean { return statsCache.isCollectingStats; }, /** * @function * @name isMoized * @memberof module:moize * @alias moize.isMoized * * @description * is the fn passed a moized function * * @param {*} fn the object to test * @returns {boolean} is fn a moized function */ isMoized(fn: any): boolean { return typeof fn === 'function' &amp;&amp; !!fn.isMoized; }, /** * @function * @name maxAge * @memberof module:moize * @alias moize.maxAge * * @description * a moized method where the age of the cache is limited to the number of milliseconds passed * * @param {number} maxAge the TTL of the value in cache * @returns {function} the moizer function */ maxAge(maxAge: number): Function { return moize({maxAge}); }, /** * @function * @name maxArgs * @memberof module:moize * @alias moize.maxArgs * * @description * a moized method where the number of arguments used for determining cache is limited to the value passed * * @param {number} maxArgs the number of args to base the key on * @returns {function} the moizer function */ maxArgs(maxArgs: number): Function { return moize({maxArgs}); }, /** * @function * @name maxSize * @memberof module:moize * @alias moize.maxSize * * @description * a moized method where the total size of the cache is limited to the value passed * * @param {number} maxSize the maximum size of the cache * @returns {function} the moizer function */ maxSize(maxSize: number): Function { return moize({maxSize}); }, /** * @function * @name promise * @memberof module:moize * @alias moize.promise * * @description * a moized method specific to caching resolved promise / async values * * @returns {function} the moizer function */ promise: moize({ isPromise: true, updateExpire: true }), /** * @function * @name react * @memberof module:moize * @alias moize.react * * @description * a moized method specific to caching React element values * * @returns {function} the moizer function */ react: moize({isReact: true}), /** * @function * @name reactSimple * @memberof module:moize * @alias moize.reactSimple * * @description * a moized method specific to caching React element values, limiting to only the most recent result * * @returns {function} the moizer function */ reactSimple: moize({isReact: true, maxSize: 1}), /** * @function * @name serialize * @memberof module:moize * @alias moize.serialize * * @description * a moized method that will serialize the arguments passed to use as the cache key * * @returns {function} the moizer function */ serialize: moize({isSerialized: true}), /** * @function * @name simple * @memberof module:moize * @alias moize.simple * * @description * a moized method that will limit the cache values to only the most recent result * * @returns {function} the moizer function */ simple: moize({maxSize: 1}) }); export default moize; × Search results Close Documentation generated by JSDoc 3.5.5 using the DocStrap template. "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" moize Modules moize Modules × Search results Close Documentation generated by JSDoc 3.5.5 using the DocStrap template. "},"index.html":{"id":"index.html","title":"Index","body":" moize Modules moize moize 5.2.0 moize moize is a consistently blazing fast memoization library for JavaScript. It handles multiple parameters (including default values) without any additional configuration, and offers a large number of options to satisfy any number of potential use-cases. Table of contents Installation Usage Configuration options equals isDeepEqual isPromise isReact isSerialized matchesKey maxAge maxArgs maxSize onCacheAdd onCacheChange onCacheHit onExpire profileName shouldSerializeFunctions serializer transformArgs updateExpire Usage with shortcut methods moize.deep moize.maxAge moize.maxArgs moize.maxSize moize.promise moize.react moize.reactSimple moize.serialize moize.simple Composition Introspection getStats isCollectingStats isMoized Collecting statistics Direct cache manipulation cache cacheSnapshot add clear get getStats has keys remove values Benchmarks Filesize Browser support Development Installation $ npm i moize --saveUsage import moize from &quot;moize&quot;; const method = (a, b) =&gt; { return a + b; }; const memoized = moize(method); memoized(2, 4); // 6 memoized(2, 4); // 6, pulled from cacheAll parameter types are supported, including circular objects, functions, etc. There are also a number of shortcut methods to memoize for unique use-cases. Configuration options moize optionally accepts an object of options as either the second parameter or as the first step in a curried function: // inline moize(fn, options); // curried moize(options)(fn);The full shape of these options: { equals: Function, // custom method to compare equality between two objects isDeepEqual: boolean, // is the cache based on deep equality of keys isPromise: boolean, // is the result a promise isReact: boolean, // is the result a React component isSerialized: boolean, // should the parameters be serialized instead of directly referenced maxAge: number, // amount of time in milliseconds before the cache will expire maxArgs: number, // maximum number of arguments to use as key for caching maxSize: number, // maximum size of cache for this method onCacheAdd: Function, // method fired when a new entry is added to cache onCacheChange: Function, // method fire when either a new entry is added to cache or the LRU ordering of the cache has changed onCacheHit: Function, // method fired when an existing entry in cache is used onExpire: Function, // method to fire when a cache entry expires (in combination with maxAge) profileName: string, // the unique identifier to give the memoized method when collecting statistics shouldSerializeFunctions: boolean, // should functions be included in the serialization of multiple parameters serializer: Function, // method to serialize the arguments to build a unique cache key transformArgs: Function, // method to transform the args into a custom format for key storage in cache updateExpire: boolean // should the cache entry's expiration be refreshed when the cache entry is hit (in combination with maxAge) }equals defaults to SameValueZero equality Custom method used to compare equality of keys for cache purposes by comparing each argument. // using lodash's deep equal comparison method const fn = ({ foo, bar }) =&gt; { return [foo, bar]; }; const memoized = moize(fn, { equals(cacheKeyArgument, keyArgument) { return cacheKeyArgument.foo === &quot;bar&quot; &amp;&amp; keyArgument.foo === &quot;bar&quot;; } }); memoized({ foo: &quot;bar&quot; }); memoized({ foo: &quot;bar&quot;, bar: &quot;baz&quot; }); // pulls from cacheThe equals method receives two parameters (cache key arguments) and should return a boolean. NOTE: This comparison is used iteratively on each argument, rather than comparing the two keys as a whole. If you want to compare the key as a whole, you should use matchesKey. isDeepEqual defaults to false Should deep equality be used to compare cache keys. This is also available via the shortcut method of moize.deep const fn = ({ foo, bar }) =&gt; { return [foo, bar]; }; const memoized = moize(fn, { isDeepEqual: true }); memoized({ foo: &quot;foo&quot;, bar: &quot;bar&quot; }); memoized({ foo: &quot;foo&quot;, bar: &quot;bar&quot; }); // pulls from cacheisPromise defaults to false Is the computed value in the function a Promise. This is also available via the shortcut method of moize.promise. const fn = async item =&gt; { return await item; }; const memoized = moize(fn, { isPromise: true });The Promise itself will be stored in cache, so that cached returns will always maintain the Promise contract. For common usage reasons, if the Promise is rejected, the cache entry will be deleted. isReact defaults to false Is the function passed a stateless functional React component. This is also available via the shortcut method of moize.react. const Foo = ({ bar, baz }) =&gt; { return ( &lt;div&gt; {bar}: {baz} &lt;/div&gt; ); }; export default moize(Foo, { isReact: true });The method will do a shallow equal comparison of both props and context of the component based on strict equality. If you want to do a deep equals comparison, set isDeepEqual to true. isSerialized defaults to false Serializes the parameters passed into a string and uses this as the key for cache comparison. This is also available via the shortcut method of moize.serialize. const fn = mutableObject =&gt; { return mutableObject.foo; }; const memoized = moize(fn, { isSerialized: true }); const object = { foo: &quot;foo&quot; }; memoized(object); // 'foo' object.foo = &quot;bar&quot;; memoized(object); // 'bar'If serialize is combined with either maxArgs or transformArgs, the following order is used: limit by maxArgs (if applicable) transform by transformArgs (if applicable) serialize by serializer NOTE: This is much slower than the default key storage, and usually the same requirements can be meet with isDeepEqual, so use at your discretion. matchesKey Custom method used to compare equality of keys for cache purposes by comparing the entire key. // using lodash's deep equal comparison method const fn = ({ foo, bar }) =&gt; { return [foo, bar]; }; const memoized = moize(fn, { matchesKey(cacheKey, key) { return ( cacheKey[0].foo === key[0].foo &amp;&amp; cacheKey[1].hasOwnProperty(&quot;bar&quot;) &amp;&amp; key[1].hasOwnProperty(&quot;bar&quot;) ); } }); memoized({ foo: &quot;bar&quot; }, { bar: null }); memoized({ foo: &quot;bar&quot; }, { bar: &quot;baz&quot; }); // pulls from cacheThe matchesKey method receives two parameters (cache keys) and should return a boolean. NOTE: This comparison uses the two keys as a whole, which is usually less performant than the equals comparison used iteratively on each argument. Generally speaking you should use the equals option for equality comparison. maxAge The maximum amount of time in milliseconds that you want a computed value to be stored in cache for this method. This is also available via the shortcut method of moize.maxAge. const fn = item =&gt; { return item; }; const memoized = moize(fn, { maxAge: 1000 * 60 * 5 // five minutes });TIP: A common usage of this is in tandom with isPromise for AJAX calls, and in that scenario the expected behavior is usually to have the maxAge countdown begin upon resolution of the promise. If this is your intended use case, you should also apply the updateExpire option. maxArgs The maximum number of arguments (starting from the first) used in creating the key for the cache. This is also available via the shortcut method of moize.maxArgs. const fn = (item1, item2, item3) =&gt; { return item1 + item2 + item3; }; const memoized = moize(fn, { maxArgs: 2 }); memoize(&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;); memoize(&quot;foo&quot;, &quot;bar&quot;, &quot;quz&quot;); // pulls from cache, as the first two args are the sameIf maxArgs is combined with either serialize or transformArgs, the following order is used: limit by maxArgs transform by transformArgs (if applicable) serialize by serializer (if applicable) maxSize defaults to Infinity The maximum number of values you want stored in cache for this method. Clearance of the cache once the maxSize is reached is on a Least Recently Used basis. This is also available via the shortcut method of moize.maxSize. const fn = item =&gt; { return item; }; const memoized = moize(fn, { maxSize: 5 });onCacheAdd Method to fire when an item has been added to cache. Receives the cache, options, and memoized function as a parameters. const fn = (foo, bar) =&gt; { return [foo, bar]; }; const moized = moize(fn, { onCacheAdd(cache, options, moized) { console.log(cache.keys); } }); moized(&quot;foo&quot;, &quot;bar&quot;); // [[&quot;foo&quot;,&quot;bar&quot;]] moized(&quot;foo&quot;, &quot;bar&quot;); moized(&quot;bar&quot;, &quot;foo&quot;); // [[&quot;bar&quot;,&quot;foo&quot;], [&quot;foo&quot;,&quot;bar&quot;]] moized(&quot;foo&quot;, &quot;bar&quot;);NOTE: When combined with onCacheChange, this method will always fire first. onCacheChange Method to fire when an item has been either added to cache, or existing cache was reordered based on a cache hit. Receives the cache, options, and memoized function as a parameters. const fn = (foo, bar) =&gt; { return [foo, bar]; }; const moized = moize(fn, { onCacheChange(cache, options, moized) { console.log(cache.keys); } }); moized(&quot;foo&quot;, &quot;bar&quot;); // [[&quot;foo&quot;,&quot;bar&quot;]] moized(&quot;foo&quot;, &quot;bar&quot;); moized(&quot;bar&quot;, &quot;foo&quot;); // [[&quot;bar&quot;,&quot;foo&quot;], [&quot;foo&quot;,&quot;bar&quot;]] moized(&quot;foo&quot;, &quot;bar&quot;); // [[&quot;foo&quot;,&quot;bar&quot;], [&quot;bar&quot;,&quot;foo&quot;]]NOTE: When combined with onCacheAdd or onCacheHit, this method will always fire last. onCacheHit Method to fire when an existing cache item is found. Receives the cache, options, and memoized function as a parameters. const fn = (foo, bar) =&gt; { return [foo, bar]; }; const moized = moize(fn, { onCacheHit(cache, options, moized) { console.log(cache.keys); } }); moized(&quot;foo&quot;, &quot;bar&quot;); moized(&quot;foo&quot;, &quot;bar&quot;); // [[&quot;foo&quot;,&quot;bar&quot;]] moized(&quot;bar&quot;, &quot;foo&quot;); moized(&quot;foo&quot;, &quot;bar&quot;); // [[&quot;bar&quot;,&quot;foo&quot;], [&quot;foo&quot;,&quot;bar&quot;]]NOTE: When combined with onCacheChange, this method will always fire first. onExpire A callback that is called when the cached entry expires. const fn = item =&gt; { return item; }; const memoized = moize(fn, { maxAge: 10000, onExpire(key) { console.log(key); } });If you return false from this method, it will prevent the key's removal and refresh the expiration in the same vein as updateExpire based on maxAge: const fn = item =&gt; { return item; }; let expirationAttempts = 0; const memoized = moize(fn, { maxAge: 1000 * 10, // 10 seconds onExpire(key) { expirationAttempts++; return expirationAttempts &lt; 2; } }); memoized(&quot;foo&quot;); // will expire key after 30 seconds, or 3 expiration attemptsNOTE: You must set a maxAge for this option to take effect. profileName defaults to function name and file/line location Name to use as unique identifier for the function when collecting statistics. collectStats(); const fn = item =&gt; { return item; }; const memoized = moize(fn, { profileName: &quot;my fancy identity&quot; });NOTE: You must be collecting statistics for this option to take effect. shouldSerializeFunctions defaults to false A custom replacer is used when serializing to ensure functions are included in the key serialization. const FunctionalComponent = ({ onClickFoo }) =&gt; { return ( &lt;button onClick={onClickFoo} type=&quot;button&quot;&gt; Click me! &lt;/button&gt; ); }; const MemoizedFunctionalComponent = moize(FunctionalComponent, { isSerialized: true, shouldSerializeFunctions: true });NOTE: You must set isSerialized for this option to take effect. serializer defaults to serializeArguments in utils.js Method used in place of the internal serializer when serializing the parameters for cache key comparison. The function accepts a single argument, the Array of args, and must also return an Array. const serializer = args =&gt; { return [JSON.stringify(args[0])]; }; const memoized = moize(fn, { isSerialized: true, serializer });NOTE: You must set isSerialized for this option to take effect. transformArgs Transform the arguments passed before it is used as a key. The function accepts a single argument, the Array of args, and must also return an Array. const fn = (one, two, three) =&gt; { return [two, three]; }; const ignoreFirstArg = args =&gt; { return args.slice(1); }; const moized = moize(fn, { transformArgs: ignoreFirstArg }); moize(&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;); moize(null, &quot;bar&quot;, &quot;baz&quot;); // pulled from cacheIf transformArgs is combined with either maxArgs or serialize, the following order is used: limit by maxArgs (if applicable) transform by transformArgs serialize by serializer (if applicable) updateExpire When a maxAge is set, clear the scheduled expiration of the key when that key is retrieved, setting a new expiration based on the most recent retrieval from cache. const fn = item =&gt; { return item; }; const memoized = moize(fn, { maxAge: 1000 * 60 * 5, // five minutes updateExpire: true }); memoized(&quot;foo&quot;); setTimeout(() =&gt; { memoized(&quot;foo&quot;); // hits cache, which updates the expire to be 5 minutes from this run instead of the first }, 1000 * 60);Usage with shortcut methods moize.deep Pre-applies the isDeepEqual option. import moize from &quot;moize&quot;; const foo = (bar, baz) =&gt; { return `${bar} ${baz}`; }; export default moize.deep(foo);moize.maxAge Pre-applies the maxAge option as a curriable method. import moize from &quot;moize&quot;; const foo = (bar, baz) =&gt; { return `${bar} ${baz}`; }; export default moize.maxAge(5000)(foo);moize.maxArgs Pre-applies the maxArgs option as a curriable method. import moize from &quot;moize&quot;; const foo = (bar, baz) =&gt; { return `${bar} ${baz}`; }; export default moize.maxArgs(1)(foo);moize.maxSize Pre-applies the maxSize option as a curriable method. import moize from &quot;moize&quot;; const foo = (bar, baz) =&gt; { return `${bar} ${baz}`; }; export default moize.maxSize(5)(foo);moize.promise Pre-applies the isPromise and updateExpire options. The updateExpire option does nothing if maxAge is not also applied, but ensures that the expiration begins at the resolution of the promise rather than the instantiation of it. import moize from &quot;moize&quot;; const foo = async (bar, baz) =&gt; { return await someApiCall(bar, baz); }; export default moize.promise(foo);NOTE: If you do not want the promise to update its expiration when the cache is hit, then you should use the isPromise option directly instead. moize.react Shortcut for memoizing functional components in React. Key comparisons are based on a shallow equal comparison of both props and context. import moize from &quot;moize&quot;; const Foo = ({ bar, baz }) =&gt; { return ( &lt;div&gt; {bar} {baz} &lt;/div&gt; ); }; export default moize.react(Foo);NOTE: This method will not operate with components made via the class instantiation, as they do not offer the same referential transparency. TIP: In usages that involve a lot of variety in the parameter changes, this has the potential for excessive memory consumption, as the cache will retain the history of all elements. It is therefore recommended to apply a maxSize, or to use the shortcut method moize.reactSimple, which automatically sets the maxSize to 1. moize.reactSimple Shortcut for memoizing functional components in React, with the cache size limited to a single entry. import moize from &quot;moize&quot;; const Foo = ({ bar, baz }) =&gt; { return ( &lt;div&gt; {bar} {baz} &lt;/div&gt; ); }; export default moize.reactSimple(Foo);NOTE: This method will not operate with components made via the class instantiation, as they do not offer the same referential transparency. moize.serialize Pre-applies the serialize option. import moize from &quot;moize&quot;; const foo = (bar, baz) =&gt; { return `${bar} ${baz}`; }; export default moize.serialize(foo);Please note that if you want to apply shouldSerializeFunctions or provide a custom serializer, you must do so with additional options: moize.serialize({ shouldSerializeFunctions: true })(fn);moize.simple Pre-applies the maxSize option with 1. import moize from &quot;moize&quot;; const foo = (bar, baz) =&gt; { return `${bar} ${baz}`; }; export default moize.simple(foo);Composition Starting with version 2.3.0, you can compose moize methods. This will create a new memoized method with the original function that shallowly merges the options of the two setups. Example: import moize from &quot;moize&quot;; const Foo = props =&gt; { return &lt;div {...props} /&gt;; }; // memoizing with react, as since 2.0.0 const MemoizedFoo = moize.react(Foo); // creating a separately-memoized method that has maxSize of 5 const LastFiveFoo = moize.maxSize(5)(MemoizedFoo);You can also create an options-first curriable version of moize if you only pass the options: import moize from &quot;moize&quot;; // creates a function that will memoize what is passed const limitedSerializedMoize = moize({ maxSize: 5, serialize: true }); const foo = bird =&gt; { return `${bird} is the word`; }; const moizedFoo = limitedSerializedMoize(foo);You can also combine all of these options with moize.compose to create moize wrappers with pre-defined options. import moize from &quot;moize&quot;; // creates a moizer that will have the options of // {isReact: true, maxAge: 5000, maxSize: 5} const superLimitedReactMoize = moize.compose( moize.react, moize.maxSize(5), moize.maxAge(5000) );Collecting statistics As-of version 5, you can collect statistics of moize to determine if your cached methods are effective. import moize, { collectStats } from &quot;moize&quot;; collectStats(); const fn = (foo, bar) =&gt; { return [foo, bar]; }; const moized = moize(fn); moized(&quot;foo&quot;, &quot;bar&quot;); moized(&quot;foo&quot;, &quot;bar&quot;); moized.getStats(); // {&quot;calls&quot;: 2, &quot;hits&quot;: 1, &quot;usage&quot;: &quot;50%&quot;}NOTE: It is recommended not to activate this in production, as it will have a performance decrease. Introspection collectStats Start collecting statistics on moized functions. The same function as if you were to import collectStats directly and call it, just placed on the default object as a convenience. moize.collectStats();getStats([profileName]) Get the statistics for a specific function, or globally. collectStats(); const fn = (foo, bar) =&gt; { return [foo, bar]; }; const moized = moize(fn); const otherFn = bar =&gt; { return bar.slice(0, 1); }; const otherMoized = moize(otherFn, { profileName: &quot;otherMoized&quot; }); moized(&quot;foo&quot;, &quot;bar&quot;); moized(&quot;foo&quot;, &quot;bar&quot;); moized.getStats(); // {&quot;calls&quot;: 2, &quot;hits&quot;: 1, &quot;usage&quot;: &quot;50%&quot;} otherMoized([&quot;baz&quot;]); moize.getStats(&quot;otherMoized&quot;); // {&quot;calls&quot;: 1, &quot;hits&quot;: 0, &quot;usage&quot;: &quot;0%&quot;} moize.getStats(); /* { &quot;calls&quot;: 3, &quot;hits&quot;: 1, &quot;profiles&quot;: { &quot;fn at Object..src/utils.js (http://localhost:3000/app.js:153:68)&quot;: { &quot;calls&quot;: 2, &quot;hits&quot;: 1, &quot;usage&quot;: &quot;50%&quot; }, &quot;otherMoized&quot;: { &quot;calls&quot;: 1, &quot;hits&quot;: 0, &quot;usage&quot;: &quot;0%&quot; } }, &quot;usage&quot;: &quot;33.3333%&quot; } */isCollectingStats Are statistics being collected on memoization usage. moize.isCollectingStats(); // false collectStats(); moize.isCollectingStats(); // trueisMoized Is the function passed a moized function. const fn = () =&gt; {}; const moizedFn = moize(fn); moize.isMoized(fn); // false moize.isMoized(moizedFn); // trueDirect cache manipulation The cache is available on the moized function as a property, and while it is not recommended to modify it directly, that option is available for edge cases. cache The shape of the cache is as follows: { keys: Array&lt;Array&lt;any&gt;&gt;, size: number, values: Array&lt;any&gt; }Regardless of how the key is transformed, it is always stored as an array (if the value returned is not an array, it is coalesced to one). NOTE: The order of keys and values should always align, so be aware when manually manipulating the cache that you need to manually keep in sync any changes to those arrays. cacheSnapshot The cache is mutated internally for performance reasons, so logging out the cache at a specific step in the workflow may not give you the information you need. As such, to help with debugging you can request the cacheSnapshot, which has the same shape as the cache but is a shallow clone of each property for persistence. There are also convenience methods provided on the moized function which allow for programmatic manipulation of the cache. add(key, value) This will manually add the value at key in cache if key does not already exist. key should be an Array of values, meant to reflect the arguments passed to the method. // single parameter is straightforward const memoized = moize(item =&gt; { return item; }); memoized.add([&quot;foo&quot;], &quot;bar&quot;); // pulls from cache memoized(&quot;foo&quot;);clear() This will clear all values in the cache, resetting it to an empty state. const memoized = moize(item =&gt; { return item; }); memoized.clear();get(key) Returns the value in cache if the key matches, else returns undefined. key should be an Array of values, meant to reflect the arguments passed to the method. const memoized = moize((first, second) =&gt; { return [first, second]; }); memoized(&quot;foo&quot;, &quot;bar&quot;); console.log(memoized.get([&quot;foo&quot;, &quot;bar&quot;])); // [&quot;foo&quot;,&quot;bar&quot;] console.log(memoized.get([&quot;bar&quot;, &quot;baz&quot;])); // undefinedgetStats() Returns the statistics for the function. collectStats(); const memoized = moize((first, second) =&gt; { return [first, second]; }); memoized(&quot;foo&quot;, &quot;bar&quot;); memoized(&quot;foo&quot;, &quot;bar&quot;); console.log(memoized.getStats()); // {&quot;calls&quot;: 2, &quot;hits&quot;: 1, &quot;usage&quot;: &quot;50%&quot;}NOTE: You must be collecting statistics for this to be populated. has(key) This will return true if a cache entry exists for the key passed, else will return false. key should be an Array of values, meant to reflect the arguments passed to the method. const memoized = moize((first, second) =&gt; { return [first, second]; }); memoized(&quot;foo&quot;, &quot;bar&quot;); console.log(memoized.has([&quot;foo&quot;, &quot;bar&quot;])); // true console.log(memoized.has([&quot;bar&quot;, &quot;baz&quot;])); // falsekeys() This will return a list of the current keys in cache. const memoized = moize(item =&gt; { return item; }); const foo = &quot;foo&quot;; memoized(foo); const bar = { baz: &quot;baz&quot; }; memoized(bar); const keys = memoized.keys(); // [['foo'], [{baz: 'baz'}]]remove(key) This will remove the provided key from cache. key should be an Array of values, meant to reflect the arguments passed to the method. const memoized = moize(item =&gt; { return item; }); const foo = { bar: &quot;baz&quot; }; memoized(foo); memoized.remove([foo]); // will re-execute, as it is no longer in cache memoized(foo);values() This will return a list of the current values in cache. const memoized = moize(item =&gt; { return { item }; }); const foo = &quot;foo&quot;; memoized(foo); const bar = { baz: &quot;baz&quot; }; memoized(bar); const values = memoized.values(); // [{item: 'foo'}, {item: {baz: 'baz'}}]Benchmarks All values provided are the number of operations per second calculated by the Benchmark suite, where a higher value is better. Each benchmark was performed using the default configuration of the library, with a fibonacci calculation based on a starting parameter of 35, using single and multiple parameters with different object types. The results were averaged to determine overall speed across possible usage. NOTE: lodash, ramda, and underscore do not support mulitple-parameter memoization without use of a resolver function. For consistency in comparison, each use the same resolver that returns the result of JSON.stringify on the arguments. Name Overall (average) Single (average) Multiple (average) single primitive single array single object multiple primitive multiple array multiple object moize 54,174,185 63,114,600 45,233,770 71,543,826 58,764,177 59,035,797 59,035,797 44,978,364 45,017,968 fast-memoize 37,591,552 74,183,948 999,155 219,504,451 1,582,247 1,465,147 1,210,230 972,741 814,496 memoizee 10,953,206 13,429,670 8,476,743 16,114,807 12,226,505 11,947,699 10,238,867 7,615,024 7,576,339 lodash 7,760,981 14,392,042 1,129,921 27,195,493 8,059,276 7,921,357 1,396,024 1,106,101 887,640 lru-memoize 6,818,881 7,216,322 6,421,440 7,761,636 7,016,605 6,870,726 6,472,962 6,323,183 6,468,176 underscore 5,140,473 9,073,217 1,207,730 22,750,266 2,419,458 2,049,928 1,490,129 1,181,751 951,310 memoizerific 4,320,437 4,784,512 3,856,362 5,608,168 4,374,440 4,370,928 4,568,332 3,455,887 3,544,867 ramda 3,831,370 6,470,175 1,192,564 15,012,589 2,380,971 2,016,966 1,470,378 1,161,390 945,926 mem 2,679,860 4,138,450 1,221,271 9,431,005 1,554,267 1,430,078 1,537,629 1,197,269 928,915 addy-osmani 2,504,948 3,224,227 1,785,669 6,430,710 1,560,466 1,681,506 3,215,093 1,184,364 957,550 Filesize moize is fairly small (about 4.1KB when minified and gzipped), however it provides a large number of configuration options to satisfy a large number of edge cases. If filesize is a concern, you may consider using micro-memoize. This is the memoization library that powers moize under-the-hood, and will handle most common use cases at 1/4 the size of moize. Browser support Chrome (all versions) Firefox (all versions) Edge (all versions) Opera 15+ IE 9+ Safari 6+ iOS 8+ Android 4+ Development Standard stuff, clone the repo and npm install dependencies. The npm scripts available: benchmark =&gt; run the benchmark suite pitting moize against other libraries in common use-cases benchmark:alternative =&gt; run the benchmark suite for alternative forms of caching in moize build =&gt; run rollup to build the distributed files in dist clean =&gt; run clean:lib, clean:es, clean:dist, and clean:docs clean:dist =&gt; run rimraf on the dist folder clean:docs =&gt; run rimraf on the docs folder clean:es =&gt; run rimraf on the es folder clean:lib =&gt; run rimraf on the lib folder dev =&gt; run webpack dev server to run example app (playground!) dist =&gt; runs clean:dist and build docs =&gt; runs clean:docs and builds the docs via jsdoc flow =&gt; runs flow check on the files in src lint =&gt; runs ESLint against all files in the src folder lint:fix =&gt; runs lint`, fixing any errors if possible postpublish =&gt; runs docs prepublish =&gt; runs compile-for-publish prepublish:compile =&gt; run lint, flow, test:coverage, transpile:lib, transpile:es, and dist test =&gt; run AVA test functions with NODE_ENV=test test:coverage =&gt; run test but with nyc for coverage checker test:watch =&gt; run test, but with persistent watcher transpile:es =&gt; run babel against all files in src to create files in es, preserving ES2015 modules (for pkg.module) transpile:lib =&gt; run babel against all files in src to create files in lib × Search results Close Documentation generated by JSDoc 3.5.5 using the DocStrap template. "},"module-moize.html":{"id":"module-moize.html","title":"Module: moize","body":" moize Modules moize Module: moize Source: index.js, line 27 Methods &lt;inner&gt; collectStats() start collecting statistics Source: index.js, line 126 &lt;inner&gt; compose(functions) method to compose moized methods and return a single moized function Parameters: Name Type Argument Description functions Array.&lt;(function())&gt; &lt;repeatable&gt; the functions to compose Source: index.js, line 137 Returns: the composed function Type function &lt;inner&gt; deep() should deep equality check be used Source: index.js, line 153 Returns: the moizer function Type function &lt;inner&gt; getStats() get the statistics of a given profile, or overall usage Source: index.js, line 166 Returns: statistics for a given profile or overall usage Type StatsProfile &lt;inner&gt; isCollectingStats() are stats being collected Source: index.js, line 179 Returns: are stats being collected Type boolean &lt;inner&gt; isMoized(fn) is the fn passed a moized function Parameters: Name Type Description fn * the object to test Source: index.js, line 194 Returns: is fn a moized function Type boolean &lt;inner&gt; maxAge(maxAge) a moized method where the age of the cache is limited to the number of milliseconds passed Parameters: Name Type Description maxAge number the TTL of the value in cache Source: index.js, line 210 Returns: the moizer function Type function &lt;inner&gt; maxArgs(maxArgs) a moized method where the number of arguments used for determining cache is limited to the value passed Parameters: Name Type Description maxArgs number the number of args to base the key on Source: index.js, line 226 Returns: the moizer function Type function &lt;inner&gt; maxSize(maxSize) a moized method where the total size of the cache is limited to the value passed Parameters: Name Type Description maxSize number the maximum size of the cache Source: index.js, line 242 Returns: the moizer function Type function &lt;inner&gt; moize(fn [, options]) memoize a function based its arguments passed, potentially improving runtime performance Parameters: Name Type Argument Default Description fn function | Options the function to memoized, or a list of options when currying options Options &lt;optional&gt; DEFAULT_OPTIONS the options to apply Source: index.js, line 33 Returns: the memoized function Type function Example import moize from 'moize'; // standard implementation const fn = (foo, bar) =&gt; `${foo} ${bar}`; const memoizedFn = moize(fn); // implementation with options const fn = async (id) =&gt; get(`http://foo.com/${id}`); const memoizedFn = moize(fn, {isPromise: true, maxSize: 5}); // implementation with convenience methods const Foo = ({foo}) =&gt; &lt;div&gt;{foo}&lt;/div&gt;; const MemoizedFoo = moize.react(Foo); &lt;inner&gt; promise() a moized method specific to caching resolved promise / async values Source: index.js, line 258 Returns: the moizer function Type function &lt;inner&gt; react() a moized method specific to caching React element values Source: index.js, line 274 Returns: the moizer function Type function &lt;inner&gt; reactSimple() a moized method specific to caching React element values, limiting to only the most recent result Source: index.js, line 287 Returns: the moizer function Type function &lt;inner&gt; serialize() a moized method that will serialize the arguments passed to use as the cache key Source: index.js, line 300 Returns: the moizer function Type function &lt;inner&gt; simple() a moized method that will limit the cache values to only the most recent result Source: index.js, line 313 Returns: the moizer function Type function × Search results Close Documentation generated by JSDoc 3.5.5 using the DocStrap template. "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
