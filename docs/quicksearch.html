<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"Cache.js.html":{"id":"Cache.js.html","title":"Source: Cache.js","body":" moize Modules moize Classes Cache Global createCurriableOptionMethod Source: Cache.js // @flow // constants import { CACHE_IDENTIFIER, ITERATOR_DONE_OBJECT } from './constants'; // types import type { IteratorDone, KeyIterator, ListItem } from './types'; // utils import { getIndexOfKey, getKeyIteratorObject, splice, unshift } from './utils'; /** * @class Cache * @classdesc class that mimics parts of the Map infrastructure, but faster */ class Cache { // $FlowIgnore computed properties not yet supported on classes [CACHE_IDENTIFIER]: boolean = true; lastItem: ?ListItem = undefined; list: Array&lt;ListItem&gt; = []; size: number = 0; /** * @function clear * @memberof Cache * @instance * * @description * remove all keys from the map */ clear(): void { this.list = []; this.setLastItem(); } /** * @function delete * @memberof Cache * @instance * * @description * remove the key from the map * * @param {*} key key to delete from the map */ delete(key: any): void { const index: number = getIndexOfKey(this, key); if (~index) { splice(this.list, index); this.setLastItem(this.list[0]); } } /** * @function get * @memberof Cache * @instance * * @description * get the value for the given key * * @param {*} key key to get the value for * @returns {*} value at the key location */ get(key: any): any { if (this.size === 0) { return undefined; } // $FlowIgnore: this.lastItem exists if (key === this.lastItem.key) { // $FlowIgnore: this.lastItem exists return this.lastItem.value; } const index: number = getIndexOfKey(this, key); if (~index) { const item: ListItem = this.list[index]; this.setLastItem(unshift(splice(this.list, index), item)); return item.value; } } /** * @function getKeyIterator * @memberof Cache * @instance * * @description * create a custom iterator for the keys in the list * * @returns {{next: (function(): Object)}} iterator instance */ getKeyIterator(): KeyIterator { let index: number = -1; return { next: (): (ListItem|IteratorDone) =&gt; { return ++index &lt; this.size ? getKeyIteratorObject(this.list[index], index) : ITERATOR_DONE_OBJECT; } }; } /** * @function has * @memberof Cache * @instance * * @description * does the map have the key provided * * @param {*} key key to test for in the map * @returns {boolean} does the map have the key */ has(key: any): boolean { // $FlowIgnore: this.lastItem exists return this.size !== 0 &amp;&amp; (key === this.lastItem.key || !!~getIndexOfKey(this, key)); } /** * @function set * @memberof Cache * @instance * * @description * set the value at the key location, or add a new item with that key value * * @param {*} key key to assign value of * @param {*} value value to store in the map at key */ set(key: any, value: any): void { this.setLastItem(unshift(this.list, { key, isMultiParamKey: !!(key &amp;&amp; key.isMultiParamKey), value })); } /** * @function setLastItem * @memberof Cache * @instance * * @description * assign the lastItem * * @param {ListItem|undefined} lastItem the item to assign */ setLastItem(lastItem: ?ListItem): void { this.lastItem = lastItem; this.size = this.list.length; } /** * @function updateItem * @memberof Cache * @instance * * @description * update an item in-place with a new value * * @param {*} key key to update value of * @param {*} value value to store in the map at key */ updateItem(key: any, value: any): void { const index: number = getIndexOfKey(this, key); if (~index) { this.list[index].value = value; // $FlowIgnore: this.lastItem exists if (key === this.lastItem.key) { // $FlowIgnore: this.lastItem exists this.lastItem.value = value; } } } } export default Cache; Ã— Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"utils.js.html":{"id":"utils.js.html","title":"Source: utils.js","body":" moize Modules moize Classes Cache Global createCurriableOptionMethod Source: utils.js // @flow // cache import Cache from './Cache'; // constants import { ARRAY_OBJECT_CLASS, CACHE_IDENTIFIER, FUNCTION_TYPEOF, FUNCTION_NAME_REGEXP, GOTCHA_OBJECT_CLASSES, OBJECT_TYPEOF, STATIC_PROPERTIES_TO_PASS, STATIC_PROPERTIES_TO_PASS_LENGTH } from './constants'; // types import type { KeyIterator, ListItem, Options } from './types'; export const jsonStringify: Function = JSON.stringify; export const keys: Function = Object.keys; export const toString: Function = Object.prototype.toString; /** * @private * * @function addStaticPropertiesToFunction * * @description * add static properties to the memoized function if they exist on the original * * @param {function} originalFunction the function to be memoized * @param {function} memoizedFn the higher-order memoized function * @returns {function} memoizedFn with static properties added */ export const addStaticPropertiesToFunction = (originalFunction: Function, memoizedFn: Function): Function =&gt; { let index: number = STATIC_PROPERTIES_TO_PASS_LENGTH, property: string; while (index--) { property = STATIC_PROPERTIES_TO_PASS[index]; if (originalFunction[property]) { memoizedFn[property] = originalFunction[property]; } } return memoizedFn; }; /** * @private * * @function compose * * @description * method to compose functions and return a single function * * @param {...Array&lt;function&gt;} functions the functions to compose * @returns {function(...Array&lt;*&gt;): *} the composed function */ export const compose = (...functions: Array&lt;Function&gt;): Function =&gt; { return functions.reduce((f: Function, g: Function): Function =&gt; { return (...args: Array&lt;any&gt;): any =&gt; { return f(g(...args)); }; }); }; /** * @private * * @function every * * @description * faster version of determining every item in array matches fn check * * @param {Array&lt;*&gt;} array array to test * @param {function} fn fn to test each item against * @returns {boolean} do all values match */ export const every = (array: Array&lt;any&gt;, fn: Function) =&gt; { let index: number = array.length; if (!index) { return true; } while (index--) { if (!fn(array[index], index)) { return false; } } return true; }; /** * @private * * @function splice * * @description * faster version of splicing a single item from the array * * @param {Array&lt;*&gt;} array array to splice from * @param {number} startingIndex index to splice at * @returns {Array&lt;*&gt;} array minus the item removed */ export const splice = (array: Array&lt;any&gt;, startingIndex: number): Array&lt;any&gt; =&gt; { const length: number = array.length; if (!length) { return array; } let index: number = startingIndex - 1; while (++index &lt; length) { array[index] = array[index + 1]; } array.length = length - 1; return array; }; /** * @private * * @function unshift * * @description * faster version of unshifting a single item into an array * * @param {Array&lt;*&gt;} array array to unshift into * @param {*} item item to unshift into array * @returns {*} the item just added to the array */ export const unshift = (array: Array&lt;any&gt;, item: any): any =&gt; { let index: number = array.length; while (index--) { array[index + 1] = array[index]; } array[0] = item; return item; }; /** * @private * * @function isCache * * @description * is the object passed an instance of the native Cache implementation * * @param {*} object object to test * @returns {boolean} is the object an instance of Cache */ export const isCache = (object: any): boolean =&gt; { return !!object[CACHE_IDENTIFIER]; }; /** * @function createCurriableOptionMethod * * @description * create a method that will curry moize with the option + value passed * * @param {function} fn the method to call * @param {string} option the name of the option to apply * @param {*} value the value to assign to option * @returns {function} the moizer with the option pre-applied */ export const createCurriableOptionMethod = (fn: Function, option: string): Function =&gt; { return function(value: any): Function { return fn({ [option]: value }); }; }; /** * @private * * @function createPluckFromInstanceList * * @description * get a property from the list on the cache * * @param {{list: Array&lt;Object&gt;}} cache cache whose list to map over * @param {string} key key to pluck from list * @returns {Array&lt;*&gt;} array of values plucked at key */ export const createPluckFromInstanceList = (cache: Cache, key: string): Function =&gt; { return !isCache(cache) ? () =&gt; {} : (): Array&lt;any&gt; =&gt; { return cache.list.map((item: ListItem) =&gt; { return item[key]; }); }; }; /** * @private * * @function getFunctionNameViaRegexp * * @description * use regexp match on stringified function to get the function name * * @param {function} fn function to get the name of * @returns {string} function name */ export const getFunctionNameViaRegexp = (fn: Function): string =&gt; { const match: ?Array&lt;string&gt; = fn.toString().match(FUNCTION_NAME_REGEXP); return match ? match[1] : ''; }; /** * @private * * @function getFunctionName * * @description * get the function name, either from modern property or regexp match, * falling back to generic string * * @param {function} fn function to get the name of * @returns {string} function name */ export const getFunctionName = (fn: Function): string =&gt; { return fn.displayName || fn.name || getFunctionNameViaRegexp(fn) || FUNCTION_TYPEOF; }; /** * @private * * @function isArrayFallback * * @description * provide fallback for native Array.isArray test * * @param {*} object object to test if it is an array * @returns {boolean} is the object passed an array or not */ export const isArrayFallback = function(object: any): boolean { return toString.call(object) === ARRAY_OBJECT_CLASS; }; /** * @private * * @function isArray * * @description * isArray function to use internally, either the native one or fallback * * @param {*} object object to test if it is an array * @returns {boolean} is the object passed an array or not */ export const isArray = Array.isArray || isArrayFallback; /** * @private * * @function isComplexObject * * @description * is the object passed a complex object * * @param {*} object object to test if it is complex * @returns {boolean} is it a complex object */ export const isComplexObject = (object: any): boolean =&gt; { return typeof object === OBJECT_TYPEOF &amp;&amp; object !== null; }; /** * @private * * @function isFunction * * @description * is the object passed a function or not * * @param {*} object object to test * @returns {boolean} is it a function */ export const isFunction = (object: any): boolean =&gt; { return typeof object === FUNCTION_TYPEOF; }; /** * @private * * @function isPlainObject * * @description * is the object passed a plain object or not * * @param {*} object object to test * @returns {boolean} is it a plain object */ export const isPlainObject = (object: any): boolean =&gt; { return isComplexObject(object) &amp;&amp; object.constructor === Object; }; /** * @private * * @function isValueObjectOrArray * * @description * check if the object is actually an object or array * * @param {*} object object to test * @returns {boolean} is the object an object or array */ export const isValueObjectOrArray = (object: any): boolean =&gt; { return isComplexObject(object) &amp;&amp; every(GOTCHA_OBJECT_CLASSES, (Class) =&gt; { return !(object instanceof Class); }); }; /** * @private * * @function customReplacer * * @description * custom replacer for the stringify function * * @param {string} key key in json object * @param {*} value value in json object * @returns {*} if function then toString of it, else the value itself */ export const customReplacer = (key: string, value: any): any =&gt; { return isFunction(value) ? `${value}` : value; }; /** * @private * * @function decycle * * @description * ES2015-ified version of cycle.decyle * * @param {*} object object to stringify * @returns {string} stringified value of object */ export const decycle = (object: any): string =&gt; { let cache: Cache = new Cache(); /** * @private * * @function coalesceCircularReferences * * @description * recursive method to replace any circular references with a placeholder * * @param {*} value value in object to decycle * @param {string} path path to reference * @returns {*} clean value */ const coalesceCircularReferences = (value: any, path: string): any =&gt; { if (!isValueObjectOrArray(value)) { return value; } if (cache.has(value)) { return { $ref: cache.get(value) }; } cache.set(value, path); if (isArray(value)) { return value.map((item, itemIndex) =&gt; { return coalesceCircularReferences(item, `${path}[${itemIndex}]`); }); } return keys(value).reduce((object, name) =&gt; { object[name] = coalesceCircularReferences(value[name], `${path}[${JSON.stringify(name)}]`); return object; }, {}); }; return coalesceCircularReferences(object, '$'); }; /** * @private * * @function deleteItemFromCache * * @description * remove an item from cache * * @param {Cache} cache caching mechanism for method * @param {*} key key to delete * @param {boolean} [isKeyLastItem=false] should the key be the last item in the LRU list */ export const deleteItemFromCache = (cache: Cache, key: any, isKeyLastItem: boolean = false) =&gt; { if (isCache(cache) &amp;&amp; isKeyLastItem) { key = cache.list[cache.list.length - 1].key; } if (cache.has(key)) { cache.delete(key); } }; /** * @private * * @function isKeyShallowEqualWithArgs * * @description * is the value passed shallowly equal with the args * * @param {*} value the value to compare * @param {Array&lt;*&gt;} args the args to test * @returns {boolean} are the args shallow equal to the value */ export const isKeyShallowEqualWithArgs = (value: any, args: Array&lt;any&gt;): boolean =&gt; { return !!(value &amp;&amp; value.isMultiParamKey) &amp;&amp; value.key.length === args.length &amp;&amp; every(args, (arg, index) =&gt; { return arg === value.key[index]; }); }; /** * @private * * @function getMultiParamKey * * @description * get the multi-parameter key that either matches a current one in state or is the same as the one passed * * @param {Cache} cache cache to compare args to * @param {Array&lt;*&gt;} args arguments passed to moize get key * @returns {Array&lt;*&gt;} either a matching key in cache or the same key as the one passed */ export const getMultiParamKey = (cache: Cache, args: Array&lt;any&gt;): Array&lt;any&gt; =&gt; { if (isKeyShallowEqualWithArgs(cache.lastItem, args)) { // $FlowIgnore cache.lastItem exists return cache.lastItem.key; } const iterator = cache.getKeyIterator(); let iteration: Object; while ((iteration = iterator.next()) &amp;&amp; !iteration.done) { if (isKeyShallowEqualWithArgs(iteration, args)) { return iteration.key; } } // $FlowIgnore ok to add key to array object args.isMultiParamKey = true; return args; }; /** * @private * * @function createAddPropertiesToFunction * * @description * add the caching mechanism to the function passed and return the function * * @param {Cache} cache caching mechanism that has get / set / has methods * @param {function} originalFunction function to get the name of * @returns {function(function): function} method that has cache mechanism added to it */ export const createAddPropertiesToFunction = (cache: Cache, originalFunction: Function, options: Options): Function =&gt; { return (fn: Function): Function =&gt; { fn.cache = cache; fn.displayName = `Memoized(${getFunctionName(originalFunction)})`; fn.isMemoized = true; fn.options = options; fn.originalFunction = originalFunction; /** * @private * * @function add * * @description * manually add an item to cache if the key does not already exist * * @param {*} key key to use in cache * @param {*} value value to assign to key */ fn.add = (key, value) =&gt; { if (!cache.get(key) &amp;&amp; getMultiParamKey(cache, key) === key) { cache.set(key, value); } }; /** * @private * * @function clear * * @description * clear the current cache for this method */ fn.clear = () =&gt; { cache.clear(); }; /** * @private * * @function delete * * @description * delete the cache for the key passed for this method * * @param {Array&lt;*&gt;} args combination of args to remove from cache */ fn.delete = (...args: Array&lt;any&gt;) =&gt; { const key = args.length === 1 &amp;&amp; args[0].isMultiParamKey ? args[0] : getMultiParamKey(cache, args); deleteItemFromCache(cache, key); }; /** * @private * * @function keys * * @description * get the list of keys currently in cache * * @returns {Array&lt;*&gt;} */ fn.keys = createPluckFromInstanceList(cache, 'key'); /** * @private * * @function values * * @description * get the list of values currently in cache * * @returns {Array&lt;*&gt;} */ fn.values = createPluckFromInstanceList(cache, 'value'); return addStaticPropertiesToFunction(originalFunction, fn); }; }; /** * @private * * @function isFiniteAndPositive * * @description * is the number passed finite and positive * * @param {number} number number to test for finiteness and positivity * @returns {boolean} is the number finite and positive */ export const isFiniteAndPositive = (number: number): boolean =&gt; { return number === ~~number &amp;&amp; number &gt; 0; }; /** * @private * * @function getIndexOfKey * * @description * get the index of the key in the map * * @param {Cache} cache cache to iterate over * @param {*} key key to find in list * @returns {number} index location of key in list */ export const getIndexOfKey = (cache: Cache, key: any): number =&gt; { const iterator: KeyIterator = cache.getKeyIterator(); let iteration: Object; while ((iteration = iterator.next()) &amp;&amp; !iteration.done) { if (iteration.key === key) { return iteration.index; } } return -1; }; /** * @private * * @function getKeyIteratorObject * * @description * get the object that is returned in the key iterator * * @param {ListItem} listItem the item in the list being iterated * @param {boolean} listItem.isMultiParamKey is the key a multi-parameter key * @param {*} listItem.key the key currently stored * @param {number} index the index of the iterator * @returns {{index: number, isMultiParamKey: boolean, key: *}} the parameters as an object */ export const getKeyIteratorObject = (listItem: ListItem, index: number): Object =&gt; { return { index, isMultiParamKey: listItem.isMultiParamKey, key: listItem.key }; }; /** * @private * * @function stringify * * @description * stringify with a custom replacer if circular, else use standard JSON.stringify * * @param {*} value value to stringify * @param {function} [replacer] replacer to used in stringification * @returns {string} the stringified version of value */ export const stringify = (value: any, replacer: ?Function) =&gt; { try { return jsonStringify(value, replacer); } catch (exception) { return jsonStringify(decycle(value), replacer); } }; /** * @private * * @function getStringifiedArgument * * @description * get the stringified version of the argument passed * * @param {*} arg argument to stringify * @param {function} [replacer] replacer to used in stringification * @returns {string} */ export const getStringifiedArgument = (arg: any, replacer: ?Function) =&gt; { return isComplexObject(arg) ? stringify(arg, replacer) : arg; }; /** * @private * * @function createArgumentSerializer * * @description * create the internal argument serializer based on the options passed * * @param {boolean} serializeFunctions should functions be included in the serialization * @param {number} maxArgs the cap on the number of arguments used in serialization * @returns {function(...Array&lt;*&gt;): string} argument serialization method */ export const createArgumentSerializer = ( serializeFunctions: boolean, maxArgs: number ): Function =&gt; { const replacer: ?Function = serializeFunctions ? customReplacer : null; const hasMaxArgs: boolean = isFiniteAndPositive(maxArgs); return (args: Array&lt;any&gt;): string =&gt; { const length: number = hasMaxArgs ? maxArgs : args.length; let index: number = -1, key: string = '|'; while (++index &lt; length) { key += `${getStringifiedArgument(args[index], replacer)}|`; } return key; }; }; /** * @private * * @function getSerializerFunction * * @description * based on the options passed, either use the serializer passed or generate the internal one * * @param {function} [serializerFromOptions] serializer function passed into options * @param {boolean} serializeFunctions should functions be included in the serialization * @param {number} maxArgs the cap on the number of arguments used in serialization * @returns {function} the function to use in serializing the arguments */ export const getSerializerFunction = ( serializerFromOptions: ?Function, serializeFunctions: boolean, maxArgs: number ): Function =&gt; { // $FlowIgnore return isFunction(serializerFromOptions) ? serializerFromOptions : createArgumentSerializer(serializeFunctions, maxArgs); }; /** * @private * * @function createGetCacheKey * * @description * get the key used for storage in the method's cache * * @param {Cache} cache cache where keys are stored * @param {boolean} serialize should the arguments be serialized into a string * @param {function} serializerFromOptions method used to serialize keys into a string * @param {boolean} serializeFunctions should functions be converted to string in serialization * @param {number} maxArgs the maximum number of arguments to use in the serialization * @returns {function(Array&lt;*&gt;): *} */ export const createGetCacheKey = ( cache: Cache, serialize: boolean, serializerFromOptions: ?Function, serializeFunctions: boolean, maxArgs: number ): Function =&gt; { if (serialize) { const serializeArguments = getSerializerFunction(serializerFromOptions, serializeFunctions, maxArgs); return (args: Array&lt;any&gt;): any =&gt; { return serializeArguments(args); }; } if (isFiniteAndPositive(maxArgs)) { return (args: Array&lt;any&gt;): any =&gt; { return args.length &gt; 1 ? getMultiParamKey(cache, args.slice(0, maxArgs)) : args[0]; }; } return (args: Array&lt;any&gt;): any =&gt; { return args.length &gt; 1 ? getMultiParamKey(cache, args) : args[0]; }; }; /** * @private * * @function setExpirationOfCache * * @description * create function to set the cache to expire after the maxAge passed (coalesced to 0) * * @param {number} maxAge number in ms to wait before expiring the cache * @returns {function(Cache, Array&lt;*&gt;): void} setExpirationOfCache method */ export const createSetExpirationOfCache = (maxAge: number) =&gt; { return (cache: Cache, key: Array&lt;any&gt;) =&gt; { setTimeout(() =&gt; { deleteItemFromCache(cache, key); }, maxAge); }; }; /** * @private * * @function createPromiseRejecter * * @description * create method that will reject the promise and delete the key from cache * * @param {Cache} cache cache to update * @param {*} key key to delete from cache * @param {function} PromiseLibrary the promise library used * @returns {function} the rejecter function for the promise */ export const createPromiseRejecter = ( cache: Cache, key: any, PromiseLibrary: Function ): Function =&gt; { return (exception: Error) =&gt; { cache.delete(key); return PromiseLibrary.reject(exception); }; }; /** * @private * * @function createPromiseResolver * * @description * create method that will resolve the promise and update the key in cache * * @param {Cache} cache cache to update * @param {*} key key to update in cache * @param {boolean} hasMaxAge should the cache expire after some time * @param {function} setExpirationOfCache function to set the expiration of cache * @param {function} PromiseLibrary the promise library used * @returns {function} the resolver function for the promise */ export const createPromiseResolver = ( cache: Cache, key: any, hasMaxAge: boolean, setExpirationOfCache: Function, PromiseLibrary: Function ): Function =&gt; { return (resolvedValue: any) =&gt; { cache.updateItem(key, PromiseLibrary.resolve(resolvedValue)); if (hasMaxAge) { setExpirationOfCache(cache, key); } return resolvedValue; }; }; /** * @private * * @function createSetNewCachedValue * * @description * assign the new value to the key in the functions cache and return the value * * @param {Cache} cache the cache to assign the value to at key * @param {boolean} isPromise is the value a promise or not * @param {number} maxAge how long should the cache persist * @param {number} maxSize the maximum number of values to store in cache * @param {Function} PromiseLibrary the library to use for resolve / reject * @returns {function(function, *, *): *} value just stored in cache */ export const createSetNewCachedValue = ( cache: Cache, isPromise: boolean, maxAge: number, maxSize: number, PromiseLibrary: Function ): Function =&gt; { const hasMaxAge: boolean = isFiniteAndPositive(maxAge); const hasMaxSize: boolean = isFiniteAndPositive(maxSize); const setExpirationOfCache: Function = createSetExpirationOfCache(maxAge); if (isPromise) { return (key: any, value: any): Promise&lt;any&gt; =&gt; { const promiseResolver = createPromiseResolver(cache, key, hasMaxAge, setExpirationOfCache, PromiseLibrary); const promiseRejecter = createPromiseRejecter(cache, key, PromiseLibrary); const handler = value.then(promiseResolver, promiseRejecter); cache.set(key, handler); if (hasMaxSize &amp;&amp; cache.size &gt; maxSize) { deleteItemFromCache(cache, undefined, true); } return handler; }; } return (key: any, value: any): any =&gt; { cache.set(key, value); if (hasMaxAge) { setExpirationOfCache(cache, key); } if (hasMaxSize &amp;&amp; cache.size &gt; maxSize) { deleteItemFromCache(cache, undefined, true); } return value; }; }; Ã— Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"index.js.html":{"id":"index.js.html","title":"Source: index.js","body":" moize Modules moize Classes Cache Global createCurriableOptionMethod Source: index.js // @flow // cache import Cache from './Cache'; // constants import { INFINITY, INVALID_FIRST_PARAMETER_ERROR, NO_PROMISE_LIBRARY_EXISTS_ERROR_MESSAGE } from './constants'; // types import type { Options } from './types'; // utils import { compose, createAddPropertiesToFunction, createCurriableOptionMethod, createGetCacheKey, createSetNewCachedValue, isFunction, isPlainObject } from './utils'; /** * @module moize */ /** * @constant {{isPromise: true}} PROMISE_OPTIONS */ const PROMISE_OPTIONS = { isPromise: true }; /** * @constant {{maxArgs: number, serialize: boolean, serializeFunctions: boolean}} REACT_OPTIONS */ const REACT_OPTIONS = { maxArgs: 2, serialize: true, serializeFunctions: true }; /** * @constant {{serialize: boolean}} SERIALIZE_OPTIONS */ const SERIALIZE_OPTIONS = { serialize: true }; /** * @function moize * * @description * store cached values returned from calling method with arguments to avoid reprocessing data from same arguments * * @example * import moize from 'moize'; * * // standard implementation * const fn = (foo, bar) =&gt; { * return `${foo} ${bar}`; * }; * const memoizedFn = moize(fn); * * // implementation with options * const fn = async (id) =&gt; { * return get(`http://foo.com/${id}`); * }; * const memoizedFn = moize(fn, { * isPromise: true, * maxSize: 5 * }); * * @param {function} functionOrComposableOptions method to memoize * @param {Options} [passedOptions={}] options to customize how the caching is handled * @param {Cache} [passedOptions.cache=new Cache()] caching mechanism to use for method * @param {boolean} [passedOptions.isPromise=false] is the function return expected to be a promise to resolve * @param {number} [passedOptions.maxAge=Infinity] the maximum age the value should persist in cache * @param {number} [passedOptions.maxArgs=Infinity] the maximum number of arguments to be used in serializing the keys * @param {number} [passedOptions.maxSize=Infinity] the maximum size of the cache to retain * @param {function} [passedOptions.promiseLibrary=Promise] promise library to use for resolution / rejection * @param {function} [passedOptions.serializeFunctions=false] should function parameters be serialized as well * @param {function} [passedOptions.serializer] method to serialize arguments with for cache storage * @returns {Function} higher-order function which either returns from cache or newly-computed value */ const moize = function(functionOrComposableOptions: (Function|Object), passedOptions: Options = {}): any { if (isPlainObject(functionOrComposableOptions)) { return function(fn: Function, otherOptions: Options = {}): Function { return moize(fn, { // $FlowIgnore functionOrComposableOptions is object of options ...functionOrComposableOptions, ...otherOptions }); }; } if (!isFunction(functionOrComposableOptions)) { throw new TypeError(INVALID_FIRST_PARAMETER_ERROR); } const isComposed: boolean = functionOrComposableOptions.isMemoized; // $FlowIgnore the value of the property is a function const fn: Function = isComposed ? functionOrComposableOptions.originalFunction : functionOrComposableOptions; const options: Object = !isComposed ? passedOptions : { ...functionOrComposableOptions.options, ...passedOptions }; const { cache = new Cache(), isPromise = false, maxAge = INFINITY, maxArgs = INFINITY, maxSize = INFINITY, promiseLibrary = Promise, serialize = false, serializeFunctions = false, serializer } = options; if (isPromise &amp;&amp; !promiseLibrary) { throw new ReferenceError(NO_PROMISE_LIBRARY_EXISTS_ERROR_MESSAGE); } const addPropertiesToFunction: Function = createAddPropertiesToFunction(cache, fn, options); const getCacheKey: Function = createGetCacheKey(cache, serialize, serializer, serializeFunctions, maxArgs); const setNewCachedValue: Function = createSetNewCachedValue(cache, isPromise, maxAge, maxSize, promiseLibrary); let key: any; /** * @private * * @function memoizedFunction * * @description * higher-order function which either returns from cache or stores newly-computed value and returns it * * @param {Array&lt;*&gt;} args arguments passed to method * @returns {any} value resulting from executing of fn passed to memoize */ const memoizedFunction = function(...args: Array&lt;any&gt;): any { key = getCacheKey(args); return cache.has(key) ? cache.get(key) : setNewCachedValue(key, fn.apply(this, args)); }; return addPropertiesToFunction(memoizedFunction); }; moize.compose = compose; moize.maxAge = createCurriableOptionMethod(moize, 'maxAge'); moize.maxArgs = createCurriableOptionMethod(moize, 'maxArgs'); moize.maxSize = createCurriableOptionMethod(moize, 'maxSize'); moize.promise = moize(PROMISE_OPTIONS); moize.react = moize(REACT_OPTIONS); moize.serialize = moize(SERIALIZE_OPTIONS); moize.simple = moize.maxSize(1); export default moize; Ã— Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"global.html":{"id":"global.html","title":"Global","body":" moize Modules moize Classes Cache Global createCurriableOptionMethod Global Methods createCurriableOptionMethod(fn, option, value) create a method that will curry moize with the option + value passed Parameters: Name Type Description fn function the method to call option string the name of the option to apply value * the value to assign to option Source: utils.js, line 174 Returns: the moizer with the option pre-applied Type function Ã— Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" moize Modules moize Classes Cache Global createCurriableOptionMethod Modules Classes Cache Ã— Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" moize Modules moize Classes Cache Global createCurriableOptionMethod Classes Classes Cache Ã— Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"index.html":{"id":"index.html","title":"Index","body":" moize Modules moize Classes Cache Global createCurriableOptionMethod moize 2.3.1 moize moize is a blazing fast memoization library for JavaScript. It handles multiple arguments out of the box (including default values), and offers options to help satisfy a number of implementation-specific needs. It has no dependencies, and is ~3kb when minified and gzipped. Table of contents Upgrade notification Installation Usage Advanced usage cache isPromise maxAge maxArgs maxSize promiseLibrary serialize serializeFunctions serializer Usage with shortcut methods moize.maxAge moize.maxArgs moize.maxSize moize.promise moize.react moize.serialize moize.simple Composition Benchmarks Direct cache manipulation add delete clear keys values Browser support Development Upgrade notification Users of moize 1.x.x will have some small but breaking changes, especially related to its use with functional components. Please see the changelog for more details about how to manage the upgrade. Installation $ npm i moize --saveUsage import moize from 'moize'; const method = (a, b) =&gt; { return a + b; }; const memoized = moize(method); memoized(2, 4); // 6 memoized(2, 4); // 6, pulled from cacheAll parameter types are supported, including circular objects, functions, etc. There are also a number of shortcut methods to easily create memoization for targeted use-cases. You can even memoize functional React components based on their props + context combination (See Usage with shortcut methods)! Advanced usage moize optionally accepts an object of options as the second parameter. The full shape of these options: { cache: Map|Object, // custom cache implementation isPromise: boolean, // is the result a promise maxAge: number, // amount of time in milliseconds before the cache will expire maxArgs: number, // maximum number of arguments to use as key for caching maxSize: number, // maximum size of cache for this method promiseLibrary: Function|Object, // promise library to use when isPromise is true, if not using native promises serialize: boolean, // should the parameters be serialized instead of directly referenced serializeFunctions: boolean, // should functions be included in the serialization of multiple parameters serializer: Function // method to serialize the arguments to build a unique cache key }cache defaults to new Map() The default cache implementation is build for speed in its purpose, however if you would like then you can pass in a custom cache implementation. This will be deprecated in the next major release. The only requirements for the cache implementation is that it matches the relevant Map API methods and properties: clear delete get has set size Additional cache-specific methods that need to be implemented: getMultiParamKey(args: Array): Array Accepts the arguments of the function itself as an Array, and returns either a key that matches one in cache already or the args passed. import isEqual from 'lodash/isEqual'; // example using a native plain object implementation const cache = { _keys: [], _values: [], size: 0, clear() { this._keys.length = 0; this._values.length = 0; this.size = 0; }, delete(key) { const index = this._keys.indexOf(key); if (!~index) { return; } this._keys.splice(index, 1); this._values.splice(index, 1); this.size--; }, get(key) { const index = this._keys.indexOf(key); return ~index ? this._values[index] : undefined; }, getMultiParamKey(args) { let index = -1; while (++index &lt; this._keys.length) { // does deepEqual comparison with existing keys if (isEqual(this._keys[index], args)) { return this._keys[index]; } } return args; }, has(key) { return !!~this._keys.indexOf(key); }, set(key, value) { const existingIndex = this._keys.indexOf(key); if (~existingIndex) { this._values[existingIndex] = value; } else { this._keys.push(key); this._values.push(key); this.size++; } return this; } }; const fn = (item) =&gt; { return item; }; const memoized = moize(fn, { cache });isPromise defaults to false Is the computed value in the function a Promise, and should we cache the resolved value from that Promise. const fn = async (item) =&gt; { return await item; }; const memoized = moize(fn, { isPromise: true });The resolved value of the Promise will be stored in cache as a Promise itself, so that cached returns will always be in the form of a Promise. For common usage reasons, if the Promise is rejected, the cache entry will be deleted. Also, if a maxAge is provided, the countdown of that TTL will begin upon the resolution of the promise rather than at the instantiation of it. maxAge defaults to Infinity The maximum amount of time in milliseconds that you want a computed value to be stored in cache for this method. const fn = (item) =&gt; { return item; }; const memoized = moize(fn, { maxAge: 1000 * 60 * 5 // five minutes });maxArgs defaults to the length of arguments passed to the method The maximum number of arguments used in creating the key for the cache. const fn = (item1, item2, item3) =&gt; { return item1 + item2 + item3; }; const memoized = moize(fn, { maxArgs: 2 });maxSize defaults to Infinity The maximum size of the cache you want stored in cache for this method. Clearance of the cache once the maxSize is reached is on a Least Recently Used basis. const fn = (item) =&gt; { return item; }; const memoized = moize(fn, { maxSize: 5 });Please note that this does not work with a custom cache implementation. promiseLibrary defaults to native Promise The promise library to use for resolution / rejection of promises. const fn = (foo) =&gt; { return new Bluebird((resolve) =&gt; { resolve(foo); }); }; const memoized = moize(fn, { isPromise: true, promiseLibrary: Bluebird });Please note that for this option to work isPromise must be set to true. You can use any library where the following aspects of the specification are included: It is thenable (the generated promise has a .then() function) The Promise object itself has .resolve() and .reject() functions on it Most modern libraries (bluebird, q, etc.) include these by default, however if you are using a custom library that does not meet these requirements then you will need to implement them yourself. An example of a wrapper that creates the .resolve() and .reject() methods: import foo from 'my-promise-library'; // create a wrapper so as not to touch the library itself const customPromise = (fn) =&gt; { return foo(fn); }; // lets pretend foo has a .result() method that has the first // parameter as successful, second as failure customPromise.resolve = function(value) { return foo.result(value); }; customPromise.reject = function(error) { return foo.result(undefined, error); }; const fn = (foo) =&gt; { return customPromise((resolve) =&gt; { resolve(foo); }); }; const memoized = moize(fn, { isPromise: true, promiseLibrary: customPromise });serialize defaults to false In moize 1.x.x, parameter serialization was used, whereas in 2.x.x and beyond we use strict equality to compare parameters. While this is both faster and more accurate, there may be scenarios where you want to serialize the parameters instead (for value equality comparison in situations where you are using mutated objects, for example). Simply pass the serialize parameter as true and you will use the performant serializer from 1.x.x. const fn = (mutableObject) =&gt; { return mutableObject.foo; }; const memoized = moize(fn, { serialize: true }); const object = { foo: 'foo' }; memoized(object); // 'foo' object.foo = 'bar'; memoized(object); // 'bar'serializeFunctions defaults to false By setting this option to true, a custom replacer will be used to ensure functions are included in the key serialization. This is especially beneficial when caching functional React components, as interactivity functions as part of props will now be included in the unique key structure (in fact, this is exactly how moize.react works). Please note that this will decrease performance of this specific function between 10-25% depending on environment. const FunctionalComponent = ({onClickFoo}) =&gt; { return ( &lt;button onClick={onClickFoo} type=&quot;button&quot; &gt; Click me! &lt;/button&gt; ) }; const MemoizedFunctionalComponent = moize(FunctionalComponent, { serialize: true, serializeFunctions: true });Please note that you must also set serialize to true for this setting to take effect. serializer defaults to serializeArguments in utils.js The default seralizer method is highly performant, and covers a number of edge cases (recursive objects, for example), however if you want to provide a custom one you may. The value returned from the function must be a valid value of keys for a Map. const serializer = (args) =&gt; { return JSON.stringify(args[0]); }; const memoized = moize(fn, { serialize: true, serializer });Please note that you must also set serialize to true for this setting to take effect. Usage with shortcut methods moize.maxAge Pre-applies the maxAge option as a curriable method: import moize from 'moize'; const foo = (bar, baz) =&gt; { return `${bar} ${baz}`; }; export default moize.maxAge(5000)(foo);moize.maxArgs Pre-applies the maxArgs option as a curriable method: import moize from 'moize'; const foo = (bar, baz) =&gt; { return `${bar} ${baz}`; }; export default moize.maxArgs(1)(foo);moize.maxSize Pre-applies the maxSize option as a curriable method: import moize from 'moize'; const foo = (bar, baz) =&gt; { return `${bar} ${baz}`; }; export default moize.maxSize(5)(foo);moize.promise Pre-applies the isPromise option: import moize from 'moize'; const foo = async (bar, baz) =&gt; { return await someApiCall(bar, baz); }; export default moize.promise(foo);moize.react Shortcut for memoizing functional components in React: Pre-applies serialize and serializeFunctions both to true, and pre-applies maxArgs to 2. This allows for a value equality comparison of props and context. import moize from 'moize'; const Foo = ({bar, baz}) =&gt; { return ( &lt;div&gt; {bar} {baz} &lt;/div&gt; ); }; export default moize.react(Foo);Also, it should be noted that in usages that involve a lot of variety in the parameter changes, this has the potential for memory leaks (as the default is to retain the history of all elements). If you expect the parameters to change more than a few times, or if you are reusing the component in several places, it is recommended to apply a maxSize (see Composition for how to combine with moize.maxSize or moize.simple). Please note moize.react will not operate with components made via the class instantiation, as they do not offer the same referential transparency. moize.serialize Pre-applies the serialize option: import moize from 'moize'; const foo = (bar, baz) =&gt; { return `${bar} ${baz}`; }; export default moize.serialize(foo);moize.simple Pre-applies the maxSize option with 1: import moize from 'moize'; const foo = (bar, baz) =&gt; { return `${bar} ${baz}`; }; export default moize.simple(foo);Composition Starting with version 2.3.0, you can compose moize methods. This will create a new memoized method with the original function that shallowly merges the options of the two setups. Example: import moize from 'moize'; const Foo = (props) =&gt; { return ( &lt;div {...props}/&gt; ); }; // memoizing with react, as since 2.0.0 const MemoizedFoo = moize.react(Foo); // creating a separately-memoized method that has maxSize of 1 const SimpleMemoizedFoo = moize.simple(MemoizedFoo);You can also create an options-first curriable version of memoize if you just pass the options: import moize from 'moize'; // creates a function that will memoize what is passed const limitedSerializedMoize = moize({ maxSize: 5, serialize: true }); const foo = (bird) =&gt; { return `${bird} is the word`; }; const moizedFoo = limitedSerializedMoize(foo);You can also combine all of these options with moize.compose to create moize wrappers with pre-defined options. import moize from 'moize'; // creates a moizer that will have the options of // {maxAge: 5000, maxSize: 1, serialize: true, serializeFunctions: true} const superLimitedReactMoize = moize.compose(moize.react, moize.simple, moize.maxAge(5000));Benchmarks All values provided are the number of operations per second (ops/sec) calculated by the Benchmark suite. Note that underscore, lodash, and ramda do not support mulitple-parameter memoization, so they are not included in those benchmarks. Each benchmark was performed using the default configuration of the library, with a fibonacci calculation based on a starting parameter of 35, and in the case of multiple parameters a second parameter (boolean for primitives, object for complex objects) was used. underscore lodash ramda memoizee fast-memoize addy-osmani memoizerific moize 9,393,399 9,679,995 1,102,656 11,651,361 31,085,245 3,656,676 2,184,221 47,089,212 memoizee fast-memoize addy-osmani memoizerific moize 8,144,578 1,256,879 1,788,762 1,433,723 9,762,395 memoizee fast-memoize addy-osmani memoizerific moize 8,208,516 1,019,949 922,261 1,419,771 9,741,543 Direct cache manipulation There are a couple of methods provided on the memoized function which allow for programmatic manipulation of the cache (please note that none of these methods will work with a custom cache implementation unless that cache implementation also has the method): add(key, value) This will manually add the value at key in cache if key does not already exist. // single parameter is straightforward const memoized = moize((item) =&gt; { return item; }); memoized.add('foo', 'bar'); // for multiple parameters, pass an array of arguments as the key const memoized = moize((item1, item2) =&gt; { return item1 + item2; }); memoized.add([1, 2], 3);clear() This will clear all values in the cache, resetting it to a default state. const memoized = moize((item) =&gt; { return item; }); memoized.clear();delete(key) This will delete the provided key from cache. // if single parameter, delete with the object itself const memoized = moize((item) =&gt; { return item; }); const foo = { bar: 'baz' }; memoized(foo); memoized.delete(foo); // if multi parameter, delete with the same arguments you passed const memoized = moize((item1, item2) =&gt; { return item1 + item2; }); const foo = 1; const bar = 2; memoized(foo, bar); memoized.delete(foo, bar);keys() This will return a list of the current keys in cache. const memoized = moize((item) =&gt; { return item; }); const foo = 'foo'; memoized(foo); const bar = { baz: 'baz' }; memoized(bar); const keys = memoized.keys(); // ['foo', {baz: 'baz'}]Please note that this is a no-op when a custom cache implementation is used. values() This will return a list of the current values in cache when the native Cache. const memoized = moize((item) =&gt; { return { item }; }); const foo = 'foo'; memoized(foo); const bar = { baz: 'baz' }; memoized(bar); const values = memoized.values(); // [{item: 'foo'}, {item: {baz: 'baz'}}]Please note that this is a no-op when a custom cache implementation is used. Browser support Chrome (all versions) Firefox (all versions) Opera 15+ Edge (all versions) IE 9+ Safari 6+ Theoretically the support should go back even farther, these are just the environments that I have tested. Development Standard stuff, clone the repo and npm install dependencies. The npm scripts available: build =&gt; run webpack to build development dist file with NODE_ENV=development build:minifed =&gt; run webpack to build production dist file with NODE_ENV=production dev =&gt; run webpack dev server to run example app (playground!) dist =&gt; runs build and build-minified docs =&gt; builds the docs via jsdoc lint =&gt; run ESLint against all files in the src folder prepublish =&gt; runs compile-for-publish prepublish:compile =&gt; run lint, test, transpile, dist test =&gt; run AVA test functions with NODE_ENV=test test:coverage =&gt; run test but with nyc for coverage checker test:watch =&gt; run test, but with persistent watcher transpile =&gt; run babel against all files in src to create files in lib Ã— Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"Cache.html":{"id":"Cache.html","title":"Class: Cache","body":" moize Modules moize Classes Cache Global createCurriableOptionMethod Class: Cache Cache class that mimics parts of the Map infrastructure, but faster new Cache() Source: Cache.js, line 20 Methods clear() remove all keys from the map Source: Cache.js, line 36 delete(key) remove the key from the map Parameters: Name Type Description key * key to delete from the map Source: Cache.js, line 50 get(key) get the value for the given key Parameters: Name Type Description key * key to get the value for Source: Cache.js, line 72 Returns: value at the key location Type * getKeyIterator() create a custom iterator for the keys in the list Source: Cache.js, line 107 Returns: iterator instance Type Object has(key) does the map have the key provided Parameters: Name Type Description key * key to test for in the map Source: Cache.js, line 131 Returns: does the map have the key Type boolean set(key, value) set the value at the key location, or add a new item with that key value Parameters: Name Type Description key * key to assign value of value * value to store in the map at key Source: Cache.js, line 149 setLastItem(lastItem) assign the lastItem Parameters: Name Type Description lastItem ListItem | undefined the item to assign Source: Cache.js, line 170 updateItem(key, value) update an item in-place with a new value Parameters: Name Type Description key * key to update value of value * value to store in the map at key Source: Cache.js, line 187 Ã— Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"module-moize.html":{"id":"module-moize.html","title":"Module: moize","body":" moize Modules moize Classes Cache Global createCurriableOptionMethod Module: moize Source: index.js, line 29 Members &lt;inner, constant&gt; PROMISE_OPTIONS :Object Type: Object Source: index.js, line 33 &lt;inner, constant&gt; REACT_OPTIONS :Object Type: Object Source: index.js, line 40 &lt;inner, constant&gt; SERIALIZE_OPTIONS :Object Type: Object Source: index.js, line 49 Methods &lt;inner&gt; moize(functionOrComposableOptions [, passedOptions]) store cached values returned from calling method with arguments to avoid reprocessing data from same arguments Parameters: Name Type Argument Default Description functionOrComposableOptions function method to memoize passedOptions Options &lt;optional&gt; {} options to customize how the caching is handled Properties Name Type Argument Default Description cache Cache &lt;optional&gt; new Cache() caching mechanism to use for method isPromise boolean &lt;optional&gt; false is the function return expected to be a promise to resolve maxAge number &lt;optional&gt; Infinity the maximum age the value should persist in cache maxArgs number &lt;optional&gt; Infinity the maximum number of arguments to be used in serializing the keys maxSize number &lt;optional&gt; Infinity the maximum size of the cache to retain promiseLibrary function &lt;optional&gt; Promise promise library to use for resolution / rejection serializeFunctions function &lt;optional&gt; false should function parameters be serialized as well serializer function &lt;optional&gt; method to serialize arguments with for cache storage Source: index.js, line 56 Returns: higher-order function which either returns from cache or newly-computed value Type function Example import moize from 'moize'; // standard implementation const fn = (foo, bar) =&gt; { return `${foo} ${bar}`; }; const memoizedFn = moize(fn); // implementation with options const fn = async (id) =&gt; { return get(`http://foo.com/${id}`); }; const memoizedFn = moize(fn, { isPromise: true, maxSize: 5 }); Ã— Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
