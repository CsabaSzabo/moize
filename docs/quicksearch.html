<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"Cache.js.html":{"id":"Cache.js.html","title":"Source: Cache.js","body":" moize Modules moize Source: Cache.js // @flow // utils import { getIndexOfKey, getKeyIteratorObject, splice, unshift } from './utils'; export type ListItem = { key: any, isMultiParamKey: boolean, value: any }; export type KeyIterator = { next: Function }; /** * @private * * @constant {Object} ITERATOR_DONE_OBJECT */ const ITERATOR_DONE_OBJECT: Object = { done: true }; /** * @private * * @class Cache * @classdesc class that mimics parts of the Map infrastructure, but faster */ class Cache { lastItem: ?ListItem = undefined; list: Array&lt;ListItem&gt; = []; size: number = 0; /** * @function clear * @memberof Cache * @instance * * @description * remove all keys from the map */ clear(): void { this.list = []; this.setLastItem(); } /** * @function delete * @memberof Cache * @instance * * @description * remove the key from the map * * @param {*} key key to delete from the map */ delete(key: any): void { const index: number = getIndexOfKey(this, key); if (~index) { splice(this.list, index); this.setLastItem(this.list[0]); } } /** * @function get * @memberof Cache * @instance * * @description * get the value for the given key * * @param {*} key key to get the value for * @returns {*} value at the key location */ get(key: any): any { if (this.size === 0) { return undefined; } // $FlowIgnore: this.lastItem exists if (key === this.lastItem.key) { // $FlowIgnore: this.lastItem exists return this.lastItem.value; } const index: number = getIndexOfKey(this, key); if (~index) { const item: ListItem = this.list[index]; this.setLastItem(unshift(splice(this.list, index), item)); // $FlowIgnore this.lastItem exists return this.lastItem.value; } } /** * @function getKeyIterator * @memberof Cache * @instance * * @description * create a custom iterator for the keys in the list * * @returns {{next: (function(): Object)}} iterator instance */ getKeyIterator(): KeyIterator { let index: number = -1; return { next: (): (ListItem|Object) =&gt; { return ++index &lt; this.size ? getKeyIteratorObject(this.list[index], index) : ITERATOR_DONE_OBJECT; } }; } /** * @function has * @memberof Cache * @instance * * @description * does the map have the key provided * * @param {*} key key to test for in the map * @returns {boolean} does the map have the key */ has(key: any): boolean { if (this.size === 0) { return false; } // $FlowIgnore: this.lastItem.key exists return key === this.lastItem.key || !!~getIndexOfKey(this, key); } /** * @function set * @memberof Cache * @instance * * @description * set the value at the key location, or add a new item with that key value * * @param {*} key key to assign value of * @param {*} value value to store in the map at key */ set(key: any, value: any): void { this.setLastItem(unshift(this.list, { key, isMultiParamKey: !!(key &amp;&amp; key.isMultiParamKey), value })); } /** * @function setLastItem * @memberof Cache * @instance * * @description * assign the lastItem * * @param {ListItem|undefined} lastItem the item to assign */ setLastItem(lastItem: ?ListItem): void { this.lastItem = lastItem; this.size = this.list.length; } /** * @function updateItem * @memberof Cache * @instance * * @description * update an item in-place with a new value * * @param {*} key key to update value of * @param {*} value value to store in the map at key */ updateItem(key: any, value: any): void { const index: number = getIndexOfKey(this, key); if (~index) { this.list[index].value = value; if (this.lastItem &amp;&amp; key === this.lastItem.key) { this.lastItem.value = value; } } } } export default Cache; × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"index.js.html":{"id":"index.js.html","title":"Source: index.js","body":" moize Modules moize Source: index.js // @flow // external dependencies import Cache from './Cache'; // utils import { createAddPropertiesToFunction, createGetCacheKey, createSetNewCachedValue, isFunction } from './utils'; type Options = { cache?: Object, isPromise?: boolean, maxAge?: number, maxArgs?: number, maxSize?: number, promiseLibrary?: Function, serialize?: boolean, serializeFunctions?: boolean, serializer?: Function }; /** * @module moize */ const INFINITY = Number.POSITIVE_INFINITY; const NOT_A_FUNCTION_ERROR = 'You must pass a function as the first parameter to moize.'; const NO_PROMISE_LIBRARY_EXISTS_ERROR_MESSAGE = 'You have not specified a promiseLibrary, and it appears that your browser does not support ' + 'native promises. You can either assign the library you are using to the global Promise object, or pass ' + 'the library in options via the &quot;promiseLibrary&quot; property.'; /** * @function moize * * @description * store cached values returned from calling method with arguments to avoid reprocessing data from same arguments * * @example * import moize from 'moize'; * * // standard implementation * const fn = (foo, bar) =&gt; { * return `${foo} ${bar}`; * }; * const memoizedFn = moize(fn); * * // implementation with options * const fn = async (id) =&gt; { * return get(`http://foo.com/${id}`); * }; * const memoizedFn = moize(fn, { * isPromise: true, * maxSize: 5 * }); * * @param {function} fn method to memoize * @param {Options} [options={}] options to customize how the caching is handled * @param {Cache} [options.cache=new Cache()] caching mechanism to use for method * @param {boolean} [options.isPromise=false] is the function return expected to be a promise to resolve * @param {number} [options.maxAge=Infinity] the maximum age the value should persist in cache * @param {number} [options.maxArgs=Infinity] the maximum number of arguments to be used in serializing the keys * @param {number} [options.maxSize=Infinity] the maximum size of the cache to retain * @param {function} [options.promiseLibrary=Promise] promise library to use for resolution / rejection * @param {function} [options.serializeFunctions=false] should function parameters be serialized as well * @param {function} [options.serializer] method to serialize arguments with for cache storage * @returns {Function} higher-order function which either returns from cache or newly-computed value */ const moize = function(fn: Function, options: Options = {}): any { if (!isFunction(fn)) { throw new TypeError(NOT_A_FUNCTION_ERROR); } if (fn.isMemoized) { return fn; } const { cache = new Cache(), isPromise = false, maxAge = INFINITY, maxArgs = INFINITY, maxSize = INFINITY, promiseLibrary = Promise, serialize = false, serializeFunctions = false, serializer } = options; if (isPromise &amp;&amp; !promiseLibrary) { throw new ReferenceError(NO_PROMISE_LIBRARY_EXISTS_ERROR_MESSAGE); } const addPropertiesToFunction: Function = createAddPropertiesToFunction(cache, fn); const getCacheKey: Function = createGetCacheKey(cache, serialize, serializer, serializeFunctions, maxArgs); const setNewCachedValue: Function = createSetNewCachedValue(cache, isPromise, maxAge, maxSize, promiseLibrary); let key: any; /** * @private * * @function memoizedFunction * * @description * higher-order function which either returns from cache or stores newly-computed value and returns it * * @param {Array&lt;*&gt;} args arguments passed to method * @returns {any} value resulting from executing of fn passed to memoize */ const memoizedFunction = function(...args: Array&lt;any&gt;): any { key = getCacheKey(args); return cache.has(key) ? cache.get(key) : setNewCachedValue(key, fn.apply(this, args)); }; return addPropertiesToFunction(memoizedFunction); }; /** * @function moize.react * * @description * react-specific memoization, with auto serialization including functions * * * @param {function} fn React functional component to memoize * @param {Options} [options={}] options to customize how the caching is handled * @returns {Function} higher-order function which either returns from cache or newly-computed ReactElement */ moize.react = function(fn: Function, options: Options = {}): any { return moize(fn, { ...options, maxArgs: 2, serialize: true, serializeFunctions: true }); }; export default moize; × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" moize Modules moize Modules × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"index.html":{"id":"index.html","title":"Index","body":" moize Modules moize moize 2.2.2 moize moize is a blazing fast memoization library for JavaScript. It handles multiple arguments out of the box (including default values), and offers options to help satisfy a number of implementation-specific needs. It has no dependencies, and is ~3kb when minified and gzipped. Table of contents Upgrade notification Installation Usage Usage with functional React components Advanced usage Direct cache manipulation Benchmarks Browser support Development Upgrade notification Users of moize 1.x.x will have some small but breaking changes, especially related to its use with functional components. Please see the changelog for more details about how to manage the upgrade. Installation $ npm i moize --saveUsage import moize from 'moize'; const method = (a, b) =&gt; { return a + b; }; const memoized = moize(method); memoized(2, 4); // 6 memoized(2, 4); // 6, pulled from cacheAll parameter types are supported, including circular objects, functions, etc. You can even memoize functional React components based on their props + context combination! Usage with functional React components Now in 2.x.x of moize you have a quick shortcut for memoizing functional components in React: import moize from 'moize'; const Foo = ({bar, baz}) =&gt; { return ( &lt;div&gt; {bar} {baz} &lt;/div&gt; ); }; export default moize.react(Foo);moize.react will auto-apply the serialize and serializeFunctions options, and set maxArgs equal to 2, which allows for a value equality comparison of props and context. You can still pass additional options in the same way you pass them in the default moize method. Please note this will not operate with components made via the class instantiation. Advanced usage moize optionally accepts an object of options as the second parameter. The full shape of these options: { cache: Map|Object, // custom cache implementation isPromise: boolean, // is the result a promise maxAge: number, // amount of time in milliseconds before the cache will expire maxArgs: number, // maximum number of arguments to use as key for caching maxSize: number, // maximum size of cache for this method promiseLibrary: Function|Object, // promise library to use when isPromise is true, if not using native promises serialize: boolean, // should the parameters be serialized instead of directly referenced serializeFunctions: boolean, // should functions be included in the serialization of multiple parameters serializer: Function // method to serialize the arguments to build a unique cache key }cache defaults to new Map() The default cache implementation is build for speed in its purpose, however if you would like then you can pass in a custom cache implementation. This will be deprecated in the next major release. The only requirements for the cache implementation is that it matches the relevant Map API methods and properties: clear delete get has set size Additional cache-specific methods that need to be implemented: getMultiParamKey(args: Array): Array Accepts the arguments of the function itself as an Array, and returns either a key that matches one in cache already or the args passed. import isEqual from 'lodash/isEqual'; // example using a native plain object implementation const cache = { _keys: [], _values: [], size: 0, clear() { this._keys.length = 0; this._values.length = 0; this.size = 0; }, delete(key) { const index = this._keys.indexOf(key); if (!~index) { return; } this._keys.splice(index, 1); this._values.splice(index, 1); this.size--; }, get(key) { const index = this._keys.indexOf(key); return ~index ? this._values[index] : undefined; }, getMultiParamKey(args) { let index = -1; while (++index &lt; this._keys.length) { // does deepEqual comparison with existing keys if (isEqual(this._keys[index], args)) { return this._keys[index]; } } return args; }, has(key) { return !!~this._keys.indexOf(key); }, set(key, value) { const existingIndex = this._keys.indexOf(key); if (~existingIndex) { this._values[existingIndex] = value; } else { this._keys.push(key); this._values.push(key); this.size++; } return this; } }; const fn = (item) =&gt; { return item; }; const memoized = moize(fn, { cache });isPromise defaults to false Is the computed value in the function a Promise, and should we cache the resolved value from that Promise. const fn = async (item) =&gt; { return await item; }; const memoized = moize(fn, { isPromise: true });The resolved value of the Promise will be stored in cache as a Promise itself, so that cached returns will always be in the form of a Promise. For common usage reasons, if the Promise is rejected, the cache entry will be deleted. Also, if a maxAge is provided, the countdown of that TTL will begin upon the resolution of the promise rather than at the instantiation of it. maxAge defaults to Infinity The maximum amount of time in milliseconds that you want a computed value to be stored in cache for this method. const fn = (item) =&gt; { return item; }; const memoized = moize(fn, { maxAge: 1000 * 60 * 5 // five minutes });maxArgs defaults to the length of arguments passed to the method The maximum number of arguments used in creating the key for the cache. const fn = (item1, item2, item3) =&gt; { return item1 + item2 + item3; }; const memoized = moize(fn, { maxArgs: 2 });maxSize defaults to Infinity The maximum size of the cache you want stored in cache for this method. Clearance of the cache once the maxSize is reached is on a Least Recently Used basis. const fn = (item) =&gt; { return item; }; const memoized = moize(fn, { maxSize: 5 });Please note that this does not work with a custom cache implementation. promiseLibrary defaults to native Promise The promise library to use for resolution / rejection of promises. const fn = (foo) =&gt; { return new Bluebird((resolve) =&gt; { resolve(foo); }); }; const memoized = moize(fn, { isPromise: true, promiseLibrary: Bluebird });Please note that for this option to work isPromise must be set to true. You can use any library where the following aspects of the specification are included: It is thenable (the generated promise has a .then() function) The Promise object itself has .resolve() and .reject() functions on it Most modern libraries (bluebird, q, etc.) include these by default, however if you are using a custom library that does not meet these requirements then you will need to implement them yourself. An example of a wrapper that creates the .resolve() and .reject() methods: import foo from 'my-promise-library'; // create a wrapper so as not to touch the library itself const customPromise = (fn) =&gt; { return foo(fn); }; // lets pretend foo has a .result() method that has the first // parameter as successful, second as failure customPromise.resolve = function(value) { return foo.result(value); }; customPromise.reject = function(error) { return foo.result(undefined, error); }; const fn = (foo) =&gt; { return customPromise((resolve) =&gt; { resolve(foo); }); }; const memoized = moize(fn, { isPromise: true, promiseLibrary: customPromise });serialize defaults to false In moize 1.x.x, parameter serialization was used, whereas in 2.x.x and beyond we use strict equality to compare parameters. While this is both faster and more accurate, there may be scenarios where you want to serialize the parameters instead (for value equality comparison in situations where you are using mutated objects, for example). Simply pass the serialize parameter as true and you will use the performant serializer from 1.x.x. const fn = (mutableObject) =&gt; { return mutableObject.foo; }; const memoized = moize(fn, { serialize: true }); const object = { foo: 'foo' }; memoized(object); // 'foo' object.foo = 'bar'; memoized(object); // 'bar'serializeFunctions defaults to false By setting this option to true, a custom replacer will be used to ensure functions are included in the key serialization. This is especially beneficial when caching functional React components, as interactivity functions as part of props will now be included in the unique key structure (in fact, this is exactly how moize.react works!). Please note that this will decrease performance of this specific function between 10-25% depending on environment. const FunctionalComponent = ({onClickFoo}) =&gt; { return ( &lt;button onClick={onClickFoo} type=&quot;button&quot; &gt; Click me! &lt;/button&gt; ) }; const MemoizedFunctionalComponent = moize(FunctionalComponent, { serializeFunctions: true });Please note that you must also set serialize to true for this setting to take effect. serializer defaults to serializeArguments in utils.js The default seralizer method is highly performant, and covers a number of edge cases (recursive objects, for example), however if you want to provide a custom one you may. The value returned from the function must be a valid value of keys for a Map. const serializer = (args) =&gt; { return JSON.stringify(args[0]); }; const memoized = moize(fn, { serializer });Please note that you must also set serialize to true for this setting to take effect. Direct cache manipulation There are a couple of methods provided on the memoized function which allow for programmatic manipulation of the cache (please note that none of these methods will work with a custom cache implementation unless that cache implementation also has the method): add(key, value) This will manually add the value at key in cache if key does not already exist. // single parameter is straightforward const memoized = moize((item) =&gt; { return item; }); memoized.add('foo', 'bar'); // for multiple parameters, pass an array of arguments as the key const memoized = moize((item1, item2) =&gt; { return item1 + item2; }); memoized.add([1, 2], 3);clear() This will clear all values in the cache, resetting it to a default state. const memoized = moize((item) =&gt; { return item; }); memoized.clear();delete(key) This will delete the provided key from cache. // if single parameter, delete with the object itself const memoized = moize((item) =&gt; { return item; }); const foo = { bar: 'baz' }; memoized(foo); memoized.delete(foo); // if multi parameter, delete with the same arguments you passed const memoized = moize((item1, item2) =&gt; { return item1 + item2; }); const foo = 1; const bar = 2; memoized(foo, bar); memoized.delete(foo, bar);keys() This will return a list of the current keys in cache. const memoized = moize((item) =&gt; { return item; }); const foo = 'foo'; memoized(foo); const bar = { baz: 'baz' }; memoized(bar); const keys = memoized.keys(); // ['foo', {baz: 'baz'}]Please note that this is a no-op when a custom cache implementation is used. values() This will return a list of the current values in cache when the native Cache. const memoized = moize((item) =&gt; { return { item }; }); const foo = 'foo'; memoized(foo); const bar = { baz: 'baz' }; memoized(bar); const values = memoized.values(); // [{item: 'foo'}, {item: {baz: 'baz'}}]Please note that this is a no-op when a custom cache implementation is used. Benchmarks All values provided are the number of operations per second (ops/sec) calculated by the Benchmark suite. Note that underscore, lodash, and ramda do not support mulitple-parameter memoization, so they are not included in those benchmarks. Each benchmark was performed using the default configuration of the library, with a fibonacci calculation based on a starting parameter of 35, and in the case of multiple parameters a second parameter (boolean for primitives, object for complex objects) was used. underscore lodash ramda memoizee fast-memoize addy-osmani memoizerific moize 9,393,399 9,679,995 1,102,656 11,651,361 31,085,245 3,656,676 2,184,221 47,089,212 memoizee fast-memoize addy-osmani memoizerific moize 8,144,578 1,256,879 1,788,762 1,433,723 9,762,395 memoizee fast-memoize addy-osmani memoizerific moize 8,208,516 1,019,949 922,261 1,419,771 9,741,543 Browser support Chrome (all versions) Firefox (all versions) Opera 15+ Edge (all versions) IE 9+ Safari 6+ Theoretically the support should go back even farther, these are just the environments that I have tested. Development Standard stuff, clone the repo and npm install dependencies. The npm scripts available: build =&gt; run webpack to build development dist file with NODE_ENV=development build:minifed =&gt; run webpack to build production dist file with NODE_ENV=production dev =&gt; run webpack dev server to run example app (playground!) dist =&gt; runs build and build-minified docs =&gt; builds the docs via jsdoc lint =&gt; run ESLint against all files in the src folder prepublish =&gt; runs compile-for-publish prepublish:compile =&gt; run lint, test, transpile, dist test =&gt; run AVA test functions with NODE_ENV=test test:coverage =&gt; run test but with nyc for coverage checker test:watch =&gt; run test, but with persistent watcher transpile =&gt; run babel against all files in src to create files in lib × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"module-moize.html":{"id":"module-moize.html","title":"Module: moize","body":" moize Modules moize Module: moize Source: index.js, line 23 Methods &lt;inner&gt; moize(fn [, options]) store cached values returned from calling method with arguments to avoid reprocessing data from same arguments Parameters: Name Type Argument Default Description fn function method to memoize options Options &lt;optional&gt; {} options to customize how the caching is handled Properties Name Type Argument Default Description cache Cache &lt;optional&gt; new Cache() caching mechanism to use for method isPromise boolean &lt;optional&gt; false is the function return expected to be a promise to resolve maxAge number &lt;optional&gt; Infinity the maximum age the value should persist in cache maxArgs number &lt;optional&gt; Infinity the maximum number of arguments to be used in serializing the keys maxSize number &lt;optional&gt; Infinity the maximum size of the cache to retain promiseLibrary function &lt;optional&gt; Promise promise library to use for resolution / rejection serializeFunctions function &lt;optional&gt; false should function parameters be serialized as well serializer function &lt;optional&gt; method to serialize arguments with for cache storage Source: index.js, line 31 Returns: higher-order function which either returns from cache or newly-computed value Type function Example import moize from 'moize'; // standard implementation const fn = (foo, bar) =&gt; { return `${foo} ${bar}`; }; const memoizedFn = moize(fn); // implementation with options const fn = async (id) =&gt; { return get(`http://foo.com/${id}`); }; const memoizedFn = moize(fn, { isPromise: true, maxSize: 5 }); × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
