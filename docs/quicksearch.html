<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"Map.js.html":{"id":"Map.js.html","title":"Source: Map.js","body":" moize Modules moize Source: Map.js // @flow // utils import { getIndexOfItemInMap, isKeyLastItem, splice } from './utils'; const HAS_MAP_SUPPORT = typeof Map === 'function'; /** * @private * * @class MapLike * @classdesc class that mimics enough of the Map infrastructure to serve as polyfill for the cache */ class MapLike { constructor() { this.list = []; this.lastItem = undefined; this.size = 0; return this; } lastItem: ?Object; list: Array&lt;any&gt;; size: number; /** * @function delete * @memberOf MapLike * @instance * * @description * remove the key from the map * * @param {*} key key to delete from the map */ delete(key: any) { if (isKeyLastItem(this.lastItem, key)) { this.lastItem = undefined; } const index: number = getIndexOfItemInMap(this, key); if (index !== -1) { this.size--; splice(this.list, index); } } /** * @function forEach * @memberOf MapLike * @instance * * @description * forEach method to loop over items in the list * * @param {function} fn function to call when looping over the list */ forEach(fn: Function) { let index: number = -1, item: ?Object; while (++index &lt; this.size) { item = this.list[index]; fn(item.value, item.key); } } /** * @function get * @memberOf MapLike * @instance * * @description * get the value for the given key * * @param {*} key key to get the value for * @returns {*} value at the key location */ get(key: any) { if (isKeyLastItem(this.lastItem, key)) { // $FlowIgnore: this.lastItem.value exists return this.lastItem.value; } const index: number = getIndexOfItemInMap(this, key); if (index !== -1) { this.lastItem = this.list[index]; return this.list[index].value; } return undefined; } /** * @function has * @memberOf MapLike * @instance * * @description * does the map have the key provided * * @param {*} key key to test for in the map * @returns {boolean} does the map have the key */ has(key: any) { if (isKeyLastItem(this.lastItem, key)) { return true; } const index = getIndexOfItemInMap(this, key); if (index !== -1) { this.lastItem = this.list[index]; return true; } return false; } /** * @function set * @memberOf MapLike * @instance * * @description * set the value at the key location, or add a new item with that key value * * @param {*} key key to assign value of * @param {*} value value to store in the map at key * @returns {MapLike} the map object */ set(key: any, value: any) { if (isKeyLastItem(this.lastItem, key)) { // $FlowIgnore: this.lastItem.value exists this.lastItem.value = value; return this; } const index: number = getIndexOfItemInMap(this, key); if (index !== -1) { this.lastItem = this.list[index]; this.list[index].value = value; return this; } this.lastItem = { key, value }; this.list.push(this.lastItem); this.size++; return this; } } export {MapLike}; export default HAS_MAP_SUPPORT ? Map : MapLike; × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"index.js.html":{"id":"index.js.html","title":"Source: index.js","body":" moize Modules moize Source: index.js // @flow // external dependencies import Map from './Map'; // utils import { createAddPropertiesToFunction, createGetCacheKey, createSetNewCachedValue, createSetUsageOrder, isFiniteAndPositive, isFunction } from './utils'; type Options = { cache?: Object, isPromise?: boolean, maxAge?: number, maxArgs?: number, maxSize?: number, serializeFunctions?: boolean, serializer?: Function }; /** * @module moize */ const INFINITY = Number.POSITIVE_INFINITY; const NOT_A_FUNCTION_ERROR = 'You must pass a function as the first parameter to moize.'; /** * @function moize * * @description * store cached values returned from calling method with arguments to avoid reprocessing data from same arguments * * @example * import moize from 'moize'; * * // standard implementation * const fn = (foo, bar) =&gt; { * return `${foo} ${bar}`; * }; * const memoizedFn = moize(fn); * * // implementation with options * const fn = async (id) =&gt; { * return get(`http://foo.com/${id}`); * }; * const memoizedFn = moize(fn, { * isPromise: true, * maxSize: 5 * }); * * @param {function} fn method to memoize * @param {Options} [options={}] options to customize how the caching is handled * @param {Map} [options.cache=new Map()] caching mechanism to use for method * @param {boolean} [options.isPromise=false] is the function return expected to be a promise to resolve * @param {number} [options.maxAge=Infinity] the maximum age the value should persist in cache * @param {number} [options.maxArgs=Infinity] the maximum number of arguments to be used in serializing the keys * @param {number} [options.maxSize=Infinity] the maximum size of the cache to retain * @param {function} [options.serializer] method to serialize arguments with for cache storage * @returns {Function} higher-order function which either returns from cache or newly-computed value */ const moize = function(fn: Function, options: Options = {}): any { if (!isFunction(fn)) { throw new TypeError(NOT_A_FUNCTION_ERROR); } const { cache = new Map(), isPromise = false, maxAge = INFINITY, maxArgs = INFINITY, maxSize = INFINITY, serializeFunctions = false, serializer } = options; const hasMaxAge: boolean = isFiniteAndPositive(maxAge); const hasMaxArgs: boolean = isFiniteAndPositive(maxArgs); const hasMaxSize: boolean = isFiniteAndPositive(maxSize); const getCacheKey: Function = createGetCacheKey(serializer, serializeFunctions, hasMaxArgs, maxArgs); const getFunctionWithAdditionalProperties: Function = createAddPropertiesToFunction(cache, fn); const setNewCachedValue: Function = createSetNewCachedValue(isPromise, hasMaxAge, maxAge); const setUsageOrder: Function = createSetUsageOrder(maxSize); let key: any; /** * @private * * @function memoizedFunction * * @description * higher-order function which either returns from cache or stores newly-computed value and returns it * * @param {Array&lt;*&gt;} args arguments passed to method * @returns {any} value resulting from executing of fn passed to memoize */ const memoizedFunction = function(...args: Array&lt;any&gt;): any { key = getCacheKey(args); if (hasMaxSize) { setUsageOrder(memoizedFunction, key); } return cache.has(key) ? cache.get(key) : setNewCachedValue(memoizedFunction, key, fn.apply(this, args)); }; return getFunctionWithAdditionalProperties(memoizedFunction); }; export default moize; × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" moize Modules moize Modules × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"index.html":{"id":"index.html","title":"Index","body":" moize Modules moize moize 1.4.4 moize moize is a blazing fast memoization library for JavaScript. It handles multiple arguments out of the box, and also offers options to help satisfy a number of implementation-specific needs. It has no dependencies, and is about 2.5kb when minified and gzipped. Table of contents Installation Usage Advanced usage Direct cache manipulation Benchmarks Browser support Development Installation $ npm i moize --saveUsage import moize from 'moize'; const method = (a, b) =&gt; { return a + b; }; const memoized = moize(method); memoized(2, 4); // 6 memoized(2, 4); // 6, pulled from cacheAll parameter types are supported, including circular objects, functions, etc. You can even memoize functional React components based on their props + context combination! Advanced usage moize also accepts an object of options as the second parameter. The full shape of these options: { cache: Map|Object, // custom cache implementation isPromise: boolean, // is the result a promise maxAge: number, // amount of time in milliseconds before the cache will expire maxArgs: number, // maximum number of arguments to use as key for caching maxSize: number, // maximum size of cache for this method serializeFunctions: boolean, // should functions be included in the serialization of multiple parameters serializer: Function // method to serialize the arguments to build a unique cache key }cache defaults to new Map() The default cache implementation is highly performant, however if you would like then you can pass in a custom cache implementation. The only requirements for the cache implementation is that it matches the relevant Map API methods: delete get has set If you want to have direct cache management using moize, the following methods must also be provided: clear forEach const cache = { delete(key) { delete this[key]; }, get(key) { return this[key]; }, has(key) { return this.hasOwnProperty[key]; }, set(key, value) { this[key] = value; return this; } }; const fn = (item) =&gt; { return item; }; const memoized = moize(fn, { cache });isPromise defaults to false Is the computed value in the function a Promise, and should we cache the resolved value from that Promise. const fn = async (item) =&gt; { return await item; }; const memoized = moize(fn, { isPromise: true });maxAge defaults to Infinity The maximum amount of time in milliseconds that you want a computed value to be stored in cache for this method. const fn = (item) =&gt; { return item; }; const memoized = moize(fn, { maxAge: 1000 * 60 * 5 // five minutes });maxArgs defaults to the length of arguments passed to the method The maximum number of arguments used in creating the key for the cache. const fn = (item1, item2, item3) =&gt; { return item1 + item2 + item3; }; const memoized = moize(fn, { maxArgs: 2 });maxSize defaults to Infinity The maximum size of the cache you want stored in cache for this method. Clearance of the cache once the maxSize is reached is on a Least Recently Used basis. const fn = (item) =&gt; { return item; }; const memoized = moize(fn, { maxSize: 5 });serializeFunctions defaults to false When multiple complex object parameters are used, they are stringified internally for fast caching, however JSON.stringify excludes functions by default. By setting this option to true, a custom replacer will be used to ensure functions are included in the key serialization. This is especially beneficial when caching functional React components, as interactivity functions as part of props will now be included in the unique key structure. Please note that this will decrease performance between 10-25% depending on environment. const FunctionalComponent = ({onClickFoo}) =&gt; { return ( &lt;button onClick={onClickFoo} type=&quot;button&quot; &gt; Click me! &lt;/button&gt; ) }; const MemoizedFunctionalComponent = moize(FunctionalComponent, { serializeFunctions: true });serializer defaults to serializeArguments in utils.js The default seralizer method is highly performant, and covers a number of edge cases (recursive objects, for example), however if you want to provide a custom one you may. The value returned from the function must be a valid value of keys for a Map. const serializer = (args) =&gt; { return JSON.stringify(args[0]); }; const memoized = moize(fn, { serializer });Direct cache manipulation There are a couple of methods provided on the memoized function which allow for programmatic manipulation of the cache: clear() This will clear all values in the cache, resetting it to a default state. const memoized = moize((item) =&gt; { return item; }); memoized.clear();delete(key) This will delete the provided key from cache. const memoized = moize((item) =&gt; { return item; }); memoized('foo'); memoized.delete('item');keys() This will return a list of the current keys in cache. const memoized = moize((item) =&gt; { return item; }); memoized('foo'); const keys = memoized.keys(); // ['item']Benchmarks All values provided are the number of operations per second (ops/sec) calculated by the Benchmark suite. Note that underscore, lodash, and ramda do not support mulitple-parameter memoization, so they are not included in those benchmarks. Each benchmark was performed using the default configuration of the library. underscore lodash ramda memoizee fast-memoize addy-osmani memoizerific moize 10,086,332 10,667,608 1,144,642 12,710,414 11,184,849 3,789,974 2,264,786 21,123,599 memoizee fast-memoize addy-osmani memoizerific moize 8,538,129 949,110 2,117,096 1,476,775 5,006,614 memoizee fast-memoize addy-osmani memoizerific moize 12,804 696,059 1,044,923 60,687 1,303,219 Browser support Chrome (all versions) Firefox (all versions) Opera 15+ Edge (all versions) IE 9+ Safari 6+ Theoretically the support should go back even farther, these are just the environments that I have tested. Development Standard stuff, clone the repo and npm install dependencies. The npm scripts available: build =&gt; run webpack to build development dist file with NODE_ENV=development build:minifed =&gt; run webpack to build production dist file with NODE_ENV=production dev =&gt; run webpack dev server to run example app (playground!) dist =&gt; runs build and build-minified docs =&gt; builds the docs via jsdoc lint =&gt; run ESLint against all files in the src folder prepublish =&gt; runs compile-for-publish prepublish:compile =&gt; run lint, test, transpile, dist test =&gt; run AVA test functions with NODE_ENV=test test:coverage =&gt; run test but with nyc for coverage checker test:watch =&gt; run test, but with persistent watcher transpile =&gt; run babel against all files in src to create files in lib × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"module-moize.html":{"id":"module-moize.html","title":"Module: moize","body":" moize Modules moize Module: moize Source: index.js, line 15 Methods &lt;inner&gt; moize(fn [, options]) store cached values returned from calling method with arguments to avoid reprocessing data from same arguments Parameters: Name Type Argument Default Description fn function method to memoize options Options &lt;optional&gt; {} options to customize how the caching is handled Properties Name Type Argument Default Description cache Map &lt;optional&gt; new Map() caching mechanism to use for method isPromise boolean &lt;optional&gt; false is the function return expected to be a promise to resolve maxAge number &lt;optional&gt; Infinity the maximum age the value should persist in cache maxArgs number &lt;optional&gt; Infinity the maximum number of arguments to be used in serializing the keys maxSize number &lt;optional&gt; Infinity the maximum size of the cache to retain serializer function &lt;optional&gt; method to serialize arguments with for cache storage Source: index.js, line 26 Returns: higher-order function which either returns from cache or newly-computed value Type function Example import moize from 'moize'; // standard implementation const fn = (foo, bar) =&gt; { return `${foo} ${bar}`; }; const memoizedFn = moize(fn); // implementation with options const fn = async (id) =&gt; { return get(`http://foo.com/${id}`); }; const memoizedFn = moize(fn, { isPromise: true, maxSize: 5 }); × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
