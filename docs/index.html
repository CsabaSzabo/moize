<!doctype html>
<html class="default no-js">
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>micro-memoize</title>
	<meta name="description" content="Documentation for micro-memoize">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="assets/css/main.css">
</head>
<body>
<header>
	<div class="tsd-page-toolbar">
		<div class="container">
			<div class="table-wrap">
				<div class="table-cell" id="tsd-search" data-index="assets/js/search.json" data-base=".">
					<div class="field">
						<label for="tsd-search-field" class="tsd-widget search no-caption">Search</label>
						<input id="tsd-search-field" type="text" />
					</div>
					<ul class="results">
						<li class="state loading">Preparing search index...</li>
						<li class="state failure">The search index is not available</li>
					</ul>
					<a href="index.html" class="title">micro-memoize</a>
				</div>
				<div class="table-cell" id="tsd-widgets">
					<div id="tsd-filter">
						<a href="#" class="tsd-widget options no-caption" data-toggle="options">Options</a>
						<div class="tsd-filter-group">
							<div class="tsd-select" id="tsd-filter-visibility">
								<span class="tsd-select-label">All</span>
								<ul class="tsd-select-list">
									<li data-value="public">Public</li>
									<li data-value="protected">Public/Protected</li>
									<li data-value="private" class="selected">All</li>
								</ul>
							</div>
							<input type="checkbox" id="tsd-filter-inherited" checked />
							<label class="tsd-widget" for="tsd-filter-inherited">Inherited</label>
							<input type="checkbox" id="tsd-filter-externals" checked />
							<label class="tsd-widget" for="tsd-filter-externals">Externals</label>
							<input type="checkbox" id="tsd-filter-only-exported" />
							<label class="tsd-widget" for="tsd-filter-only-exported">Only exported</label>
						</div>
					</div>
					<a href="#" class="tsd-widget menu no-caption" data-toggle="menu">Menu</a>
				</div>
			</div>
		</div>
	</div>
	<div class="tsd-page-title">
		<div class="container">
			<ul class="tsd-breadcrumb">
				<li>
					<a href="globals.html">Globals</a>
				</li>
			</ul>
			<h1>micro-memoize</h1>
		</div>
	</div>
</header>
<div class="container container-main">
	<div class="row">
		<div class="col-8 col-content">
			<div class="tsd-panel tsd-typography">
				<a href="#micro-memoize" id="micro-memoize" style="color: inherit; text-decoration: none;">
					<h1>micro-memoize</h1>
				</a>
				<p>A tiny, crazy <a href="#benchmarks">fast</a> memoization library for the 95% use-case</p>
				<a href="#table-of-contents" id="table-of-contents" style="color: inherit; text-decoration: none;">
					<h2>Table of contents</h2>
				</a>
				<ul>
					<li><a href="#micro-memoize">micro-memoize</a><ul>
							<li><a href="#table-of-contents">Table of contents</a></li>
							<li><a href="#summary">Summary</a></li>
							<li><a href="#importing">Importing</a></li>
							<li><a href="#usage">Usage</a><ul>
									<li><a href="#types">Types</a></li>
									<li><a href="#composition">Composition</a></li>
								</ul>
							</li>
							<li><a href="#options">Options</a><ul>
									<li><a href="#isequal">isEqual</a></li>
									<li><a href="#ismatchingkey">isMatchingKey</a></li>
									<li><a href="#ispromise">isPromise</a></li>
									<li><a href="#maxsize">maxSize</a></li>
									<li><a href="#oncacheadd">onCacheAdd</a></li>
									<li><a href="#oncachechange">onCacheChange</a></li>
									<li><a href="#oncachehit">onCacheHit</a></li>
									<li><a href="#transformkey">transformKey</a></li>
								</ul>
							</li>
							<li><a href="#additional-properties">Additional properties</a><ul>
									<li><a href="#memoizedcache">memoized.cache</a><ul>
											<li><a href="#memoizedcachesnapshot">memoized.cache.snapshot</a></li>
										</ul>
									</li>
									<li><a href="#memoizedfn">memoized.fn</a></li>
									<li><a href="#memoizedismemoized">memoized.isMemoized</a></li>
									<li><a href="#memoizedoptions">memoized.options</a></li>
								</ul>
							</li>
							<li><a href="#benchmarks">Benchmarks</a><ul>
									<li><a href="#single-parameter-primitive-only">Single parameter (primitive only)</a></li>
									<li><a href="#single-parameter-complex-object">Single parameter (complex object)</a></li>
									<li><a href="#multiple-parameters-primitives-only">Multiple parameters (primitives only)</a></li>
									<li><a href="#multiple-parameters-complex-objects">Multiple parameters (complex objects)</a></li>
								</ul>
							</li>
							<li><a href="#browser-support">Browser support</a></li>
							<li><a href="#node-support">Node support</a></li>
							<li><a href="#development">Development</a></li>
						</ul>
					</li>
				</ul>
				<a href="#summary" id="summary" style="color: inherit; text-decoration: none;">
					<h2>Summary</h2>
				</a>
				<p>As the author of <a href="https://github.com/planttheidea/moize"><code>moize</code></a>, I created a consistently fast memoization library, but <code>moize</code> has a lot of features to satisfy a large number of edge cases. <code>micro-memoize</code> is a simpler approach, focusing on the core feature set with a much smaller footprint (~1.5kB minified+gzipped). Stripping out these edge cases also allows <code>micro-memoize</code> to be faster across the board than <code>moize</code>.</p>
				<a href="#importing" id="importing" style="color: inherit; text-decoration: none;">
					<h2>Importing</h2>
				</a>
				<p>ESM in browsers:</p>
				<pre><code class="language-ts"><span class="hljs-keyword">import</span> memoize <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;micro-memoize&quot;</span>;</code></pre>
				<p>ESM in NodeJS:</p>
				<pre><code class="language-ts"><span class="hljs-keyword">import</span> memoize <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;micro-memoize/mjs&quot;</span>;</code></pre>
				<p>CommonJS:</p>
				<pre><code class="language-ts"><span class="hljs-keyword">const</span> memoize = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;micro-memoize&quot;</span>);</code></pre>
				<a href="#usage" id="usage" style="color: inherit; text-decoration: none;">
					<h2>Usage</h2>
				</a>
				<pre><code class="language-ts"><span class="hljs-keyword">const</span> assembleToObject = <span class="hljs-function">(<span class="hljs-params">one: <span class="hljs-built_in">string</span>, two: <span class="hljs-built_in">string</span></span>) =&gt;</span> ({ one, two });

<span class="hljs-keyword">const</span> memoized = memoize(assembleToObject);

<span class="hljs-built_in">console</span>.log(memoized(<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>)); <span class="hljs-comment">// {one: &#x27;one&#x27;, two: &#x27;two&#x27;}</span>
<span class="hljs-built_in">console</span>.log(memoized(<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>)); <span class="hljs-comment">// pulled from cache, {one: &#x27;one&#x27;, two: &#x27;two&#x27;}</span></code></pre>
				<a href="#types" id="types" style="color: inherit; text-decoration: none;">
					<h3>Types</h3>
				</a>
				<p>If you need them, all types are available under the <code>MicroMemoize</code> namespace.</p>
				<pre><code class="language-ts"><span class="hljs-keyword">import</span> { MicroMemoize } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;micro-memoize&quot;</span>;</code></pre>
				<a href="#composition" id="composition" style="color: inherit; text-decoration: none;">
					<h3>Composition</h3>
				</a>
				<p>Starting in <code>4.0.0</code>, you can compose memoized functions if you want to have multiple types of memoized versions based on different options.</p>
				<pre><code class="language-ts"><span class="hljs-keyword">const</span> simple = memoized(fn); <span class="hljs-comment">// { maxSize: 1 }</span>
<span class="hljs-keyword">const</span> upToFive = memoized(simple, { <span class="hljs-attr">maxSize</span>: <span class="hljs-number">5</span> }); <span class="hljs-comment">// { maxSize: 5 }</span>
<span class="hljs-keyword">const</span> withCustomEquals = memoized(upToFive, { <span class="hljs-attr">isEqual</span>: deepEqual }); <span class="hljs-comment">// { maxSize: 5, isEqual: deepEqual }</span></code></pre>
				<p><strong>NOTE</strong>: The original function is the function used in the composition, the composition only applies to the options. In the example above, <code>upToFive</code> does not call <code>simple</code>, it calls <code>fn</code>.</p>
				<a href="#options" id="options" style="color: inherit; text-decoration: none;">
					<h2>Options</h2>
				</a>
				<a href="#isequal" id="isequal" style="color: inherit; text-decoration: none;">
					<h3>isEqual</h3>
				</a>
				<p><code>function(object1: any, object2: any): boolean</code>, <em>defaults to <code>isSameValueZero</code></em></p>
				<p>Custom method to compare equality of keys, determining whether to pull from cache or not, by comparing each argument in order.</p>
				<p>Common use-cases:</p>
				<ul>
					<li>Deep equality comparison</li>
					<li>Limiting the arguments compared</li>
				</ul>
				<pre><code class="language-ts"><span class="hljs-keyword">import</span> { deepEqual } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;fast-equals&quot;</span>;

<span class="hljs-keyword">type</span> ContrivedObject = {
  <span class="hljs-attr">deep</span>: <span class="hljs-built_in">string</span>;
};

<span class="hljs-keyword">const</span> deepObject = <span class="hljs-function">(<span class="hljs-params"><span class="hljs-built_in">object</span>: {
  foo: ContrivedObject;
  bar: ContrivedObject;
}</span>) =&gt;</span> ({
  <span class="hljs-attr">foo</span>: <span class="hljs-built_in">object</span>.foo,
  <span class="hljs-attr">bar</span>: <span class="hljs-built_in">object</span>.bar
});

<span class="hljs-keyword">const</span> memoizedDeepObject = memoize(deepObject, { <span class="hljs-attr">isEqual</span>: deepEqual });

<span class="hljs-built_in">console</span>.log(
  memoizedDeepObject({
    <span class="hljs-attr">foo</span>: {
      <span class="hljs-attr">deep</span>: <span class="hljs-string">&quot;foo&quot;</span>
    },
    <span class="hljs-attr">bar</span>: {
      <span class="hljs-attr">deep</span>: <span class="hljs-string">&quot;bar&quot;</span>
    },
    <span class="hljs-attr">baz</span>: {
      <span class="hljs-attr">deep</span>: <span class="hljs-string">&quot;baz&quot;</span>
    }
  })
); <span class="hljs-comment">// {foo: {deep: &#x27;foo&#x27;}, bar: {deep: &#x27;bar&#x27;}}</span>

<span class="hljs-built_in">console</span>.log(
  memoizedDeepObject({
    <span class="hljs-attr">foo</span>: {
      <span class="hljs-attr">deep</span>: <span class="hljs-string">&quot;foo&quot;</span>
    },
    <span class="hljs-attr">bar</span>: {
      <span class="hljs-attr">deep</span>: <span class="hljs-string">&quot;bar&quot;</span>
    },
    <span class="hljs-attr">baz</span>: {
      <span class="hljs-attr">deep</span>: <span class="hljs-string">&quot;baz&quot;</span>
    }
  })
); <span class="hljs-comment">// pulled from cache</span></code></pre>
				<p><strong>NOTE</strong>: The default method tests for <a href="http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero">SameValueZero</a> equality, which is summarized as strictly equal while also considering <code>NaN</code> equal to <code>NaN</code>.</p>
				<a href="#ismatchingkey" id="ismatchingkey" style="color: inherit; text-decoration: none;">
					<h3>isMatchingKey</h3>
				</a>
				<p><code>function(object1: any[], object2: any[]): boolean</code></p>
				<p>Custom method to compare equality of keys, determining whether to pull from cache or not, by comparing the entire key.</p>
				<p>Common use-cases:</p>
				<ul>
					<li>Comparing the shape of the key</li>
					<li>Matching on values regardless of order</li>
					<li>Serialization of arguments</li>
				</ul>
				<pre><code class="language-ts"><span class="hljs-keyword">import</span> { deepEqual } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;fast-equals&quot;</span>;

<span class="hljs-keyword">type</span> ContrivedObject = { <span class="hljs-attr">foo</span>: <span class="hljs-built_in">string</span>; bar: <span class="hljs-built_in">number</span> };

<span class="hljs-keyword">const</span> deepObject = <span class="hljs-function">(<span class="hljs-params"><span class="hljs-built_in">object</span>: ContrivedObject</span>) =&gt;</span> ({
  <span class="hljs-attr">foo</span>: <span class="hljs-built_in">object</span>.foo,
  <span class="hljs-attr">bar</span>: <span class="hljs-built_in">object</span>.bar
});

<span class="hljs-keyword">const</span> memoizedShape = memoize(deepObject, {
  <span class="hljs-comment">// receives the full key in cache and the full key of the most recent call</span>
  <span class="hljs-function"><span class="hljs-title">isMatchingKey</span>(<span class="hljs-params">[object1]: [ContrivedObject], [object2]: [ContrivedObject]</span>)</span> {
    <span class="hljs-keyword">return</span> (
      object1.hasOwnProperty(<span class="hljs-string">&quot;foo&quot;</span>) &amp;&amp;
      object2.hasOwnProperty(<span class="hljs-string">&quot;foo&quot;</span>) &amp;&amp;
      object1.bar === object2.bar
    );
  }
});

<span class="hljs-built_in">console</span>.log(
  memoizedShape({
    <span class="hljs-attr">foo</span>: <span class="hljs-string">&quot;foo&quot;</span>,
    <span class="hljs-attr">bar</span>: <span class="hljs-string">&quot;bar&quot;</span>,
    <span class="hljs-attr">baz</span>: <span class="hljs-string">&quot;baz&quot;</span>
  })
); <span class="hljs-comment">// {foo: {deep: &#x27;foo&#x27;}, bar: {deep: &#x27;bar&#x27;}}</span>

<span class="hljs-built_in">console</span>.log(
  memoizedShape({
    <span class="hljs-attr">foo</span>: <span class="hljs-string">&quot;not foo&quot;</span>,
    <span class="hljs-attr">bar</span>: <span class="hljs-string">&quot;bar&quot;</span>,
    <span class="hljs-attr">baz</span>: <span class="hljs-string">&quot;baz&quot;</span>
  })
); <span class="hljs-comment">// pulled from cache</span></code></pre>
				<a href="#ispromise" id="ispromise" style="color: inherit; text-decoration: none;">
					<h3>isPromise</h3>
				</a>
				<p><code>boolean</code>, <em>defaults to <code>false</code></em></p>
				<p>Identifies the value returned from the method as a <code>Promise</code>, which will result in one of two possible scenarios:</p>
				<ul>
					<li>If the promise is resolved, it will fire the <code>onCacheHit</code> and <code>onCacheChange</code> options</li>
					<li>If the promise is rejected, it will trigger auto-removal from cache</li>
				</ul>
				<pre><code class="language-ts"><span class="hljs-keyword">const</span> fn = <span class="hljs-keyword">async</span> (one: <span class="hljs-built_in">string</span>, <span class="hljs-attr">two</span>: <span class="hljs-built_in">string</span>) =&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
      reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>({ one, two }));
    }, <span class="hljs-number">500</span>);
  });
};

<span class="hljs-keyword">const</span> memoized = memoize(fn, { <span class="hljs-attr">isPromise</span>: <span class="hljs-literal">true</span> });

memoized(<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>);

<span class="hljs-built_in">console</span>.log(memoized.cache.snapshot.keys); <span class="hljs-comment">// [[&#x27;one&#x27;, &#x27;two&#x27;]]</span>
<span class="hljs-built_in">console</span>.log(memoized.cache.snapshot.values); <span class="hljs-comment">// [Promise]</span>

<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(memoized.cache.snapshot.keys); <span class="hljs-comment">// []</span>
  <span class="hljs-built_in">console</span>.log(memoized.cache.snapshot.values); <span class="hljs-comment">// []</span>
}, <span class="hljs-number">1000</span>);</code></pre>
				<p><strong>NOTE</strong>: If you don&#39;t want rejections to auto-remove the entry from cache, set <code>isPromise</code> to <code>false</code> (or simply do not set it), but be aware this will also remove the cache listeners that fire on successful resolution.</p>
				<a href="#maxsize" id="maxsize" style="color: inherit; text-decoration: none;">
					<h3>maxSize</h3>
				</a>
				<p><code>number</code>, <em>defaults to <code>1</code></em></p>
				<p>The number of values to store in cache, based on a <a href="https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_Recently_Used_.28LRU.29">Least Recently Used</a> basis. This operates the same as <a href="https://github.com/planttheidea/moize#maxsize"><code>maxSize</code></a> on <code>moize</code>, with the exception of the default being different.</p>
				<pre><code class="language-ts"><span class="hljs-keyword">const</span> manyPossibleArgs = <span class="hljs-function">(<span class="hljs-params">one: <span class="hljs-built_in">string</span>, two: <span class="hljs-built_in">string</span></span>) =&gt;</span> [one, two];

<span class="hljs-keyword">const</span> memoized = memoize(manyPossibleArgs, { <span class="hljs-attr">maxSize</span>: <span class="hljs-number">3</span> });

<span class="hljs-built_in">console</span>.log(memoized(<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>)); <span class="hljs-comment">// [&#x27;one&#x27;, &#x27;two&#x27;]</span>
<span class="hljs-built_in">console</span>.log(memoized(<span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>)); <span class="hljs-comment">// [&#x27;two&#x27;, &#x27;three&#x27;]</span>
<span class="hljs-built_in">console</span>.log(memoized(<span class="hljs-string">&quot;three&quot;</span>, <span class="hljs-string">&quot;four&quot;</span>)); <span class="hljs-comment">// [&#x27;three&#x27;, &#x27;four&#x27;]</span>

<span class="hljs-built_in">console</span>.log(memoized(<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>)); <span class="hljs-comment">// pulled from cache</span>
<span class="hljs-built_in">console</span>.log(memoized(<span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>)); <span class="hljs-comment">// pulled from cache</span>
<span class="hljs-built_in">console</span>.log(memoized(<span class="hljs-string">&quot;three&quot;</span>, <span class="hljs-string">&quot;four&quot;</span>)); <span class="hljs-comment">// pulled from cache</span>

<span class="hljs-built_in">console</span>.log(memoized(<span class="hljs-string">&quot;four&quot;</span>, <span class="hljs-string">&quot;five&quot;</span>)); <span class="hljs-comment">// [&#x27;four&#x27;, &#x27;five&#x27;], drops [&#x27;one&#x27;, &#x27;two&#x27;] from cache</span></code></pre>
				<p><strong>NOTE</strong>: The default for <code>micro-memoize</code> differs from the default implementation of <code>moize</code>. <code>moize</code> will store an infinite number of results unless restricted, whereas <code>micro-memoize</code> will only store the most recent result. In this way, the default implementation of <code>micro-memoize</code> operates more like <a href="https://github.com/planttheidea/moize#moizesimple"><code>moize.simple</code></a>.</p>
				<a href="#oncacheadd" id="oncacheadd" style="color: inherit; text-decoration: none;">
					<h3>onCacheAdd</h3>
				</a>
				<p><code>function(cache: Cache, options: Options): void</code></p>
				<p>Callback method that executes whenever the cache is added to. This is mainly to allow for higher-order caching managers that use <code>micro-memoize</code> to perform superset functionality on the <code>cache</code> object.</p>
				<pre><code class="language-ts"><span class="hljs-keyword">const</span> fn = <span class="hljs-function">(<span class="hljs-params">one: <span class="hljs-built_in">string</span>, two: <span class="hljs-built_in">string</span></span>) =&gt;</span> [one, two];

<span class="hljs-keyword">const</span> memoized = memoize(fn, {
  <span class="hljs-function"><span class="hljs-title">onCacheAdd</span>(<span class="hljs-params">cache: Cache, options: Options</span>)</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;cache has been added to: &quot;</span>, cache);
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;memoized method has the following options applied: &quot;</span>, options);
  }
});

memoized(<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;bar&quot;</span>); <span class="hljs-comment">// cache has been added to</span>
memoized(<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;bar&quot;</span>);
memoized(<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;bar&quot;</span>);

memoized(<span class="hljs-string">&quot;bar&quot;</span>, <span class="hljs-string">&quot;foo&quot;</span>); <span class="hljs-comment">// cache has been added to</span>
memoized(<span class="hljs-string">&quot;bar&quot;</span>, <span class="hljs-string">&quot;foo&quot;</span>);
memoized(<span class="hljs-string">&quot;bar&quot;</span>, <span class="hljs-string">&quot;foo&quot;</span>);

memoized(<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;bar&quot;</span>);
memoized(<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;bar&quot;</span>);
memoized(<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;bar&quot;</span>);</code></pre>
				<p><strong>NOTE</strong>: This method is not executed when the <code>cache</code> is manually manipulated, only when changed via calling the memoized method.</p>
				<a href="#oncachechange" id="oncachechange" style="color: inherit; text-decoration: none;">
					<h3>onCacheChange</h3>
				</a>
				<p><code>function(cache: Cache, options: Options): void</code></p>
				<p>Callback method that executes whenever the cache is added to or the order is updated. This is mainly to allow for higher-order caching managers that use <code>micro-memoize</code> to perform superset functionality on the <code>cache</code> object.</p>
				<pre><code class="language-ts"><span class="hljs-keyword">const</span> fn = <span class="hljs-function">(<span class="hljs-params">one: <span class="hljs-built_in">string</span>, two: <span class="hljs-built_in">string</span></span>) =&gt;</span> [one, two];

<span class="hljs-keyword">const</span> memoized = memoize(fn, {
  <span class="hljs-function"><span class="hljs-title">onCacheChange</span>(<span class="hljs-params">cache: Cache, options: Options</span>)</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;cache has changed: &quot;</span>, cache);
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;memoized method has the following options applied: &quot;</span>, options);
  }
});

memoized(<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;bar&quot;</span>); <span class="hljs-comment">// cache has changed</span>
memoized(<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;bar&quot;</span>);
memoized(<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;bar&quot;</span>);

memoized(<span class="hljs-string">&quot;bar&quot;</span>, <span class="hljs-string">&quot;foo&quot;</span>); <span class="hljs-comment">// cache has changed</span>
memoized(<span class="hljs-string">&quot;bar&quot;</span>, <span class="hljs-string">&quot;foo&quot;</span>);
memoized(<span class="hljs-string">&quot;bar&quot;</span>, <span class="hljs-string">&quot;foo&quot;</span>);

memoized(<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;bar&quot;</span>); <span class="hljs-comment">// cache has changed</span>
memoized(<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;bar&quot;</span>);
memoized(<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;bar&quot;</span>);</code></pre>
				<p><strong>NOTE</strong>: This method is not executed when the <code>cache</code> is manually manipulated, only when changed via calling the memoized method. When the execution of other cache listeners (<code>onCacheAdd</code>, <code>onCacheHit</code>) is applicable, this method will execute after those methods.</p>
				<a href="#oncachehit" id="oncachehit" style="color: inherit; text-decoration: none;">
					<h3>onCacheHit</h3>
				</a>
				<p><code>function(cache: Cache, options: Options): void</code></p>
				<p>Callback method that executes whenever the cache is hit, whether the order is updated or not. This is mainly to allow for higher-order caching managers that use <code>micro-memoize</code> to perform superset functionality on the <code>cache</code> object.</p>
				<pre><code class="language-ts"><span class="hljs-keyword">const</span> fn = <span class="hljs-function">(<span class="hljs-params">one: <span class="hljs-built_in">string</span>, two: <span class="hljs-built_in">string</span></span>) =&gt;</span> [one, two];

<span class="hljs-keyword">const</span> memoized = memoize(fn, {
  <span class="hljs-attr">maxSize</span>: <span class="hljs-number">2</span>,
  <span class="hljs-function"><span class="hljs-title">onCacheHit</span>(<span class="hljs-params">cache: Cache, options: Options</span>)</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;cache was hit: &quot;</span>, cache);
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;memoized method has the following options applied: &quot;</span>, options);
  }
});

memoized(<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;bar&quot;</span>);
memoized(<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;bar&quot;</span>); <span class="hljs-comment">// cache was hit</span>
memoized(<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;bar&quot;</span>); <span class="hljs-comment">// cache was hit</span>

memoized(<span class="hljs-string">&quot;bar&quot;</span>, <span class="hljs-string">&quot;foo&quot;</span>);
memoized(<span class="hljs-string">&quot;bar&quot;</span>, <span class="hljs-string">&quot;foo&quot;</span>); <span class="hljs-comment">// cache was hit</span>
memoized(<span class="hljs-string">&quot;bar&quot;</span>, <span class="hljs-string">&quot;foo&quot;</span>); <span class="hljs-comment">// cache was hit</span>

memoized(<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;bar&quot;</span>); <span class="hljs-comment">// cache was hit</span>
memoized(<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;bar&quot;</span>); <span class="hljs-comment">// cache was hit</span>
memoized(<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;bar&quot;</span>); <span class="hljs-comment">// cache was hit</span></code></pre>
				<p><strong>NOTE</strong>: This method is not executed when the <code>cache</code> is manually manipulated, only when changed via calling the memoized method.</p>
				<a href="#transformkey" id="transformkey" style="color: inherit; text-decoration: none;">
					<h3>transformKey</h3>
				</a>
				<p><code>function(Array&lt;any&gt;): any</code></p>
				<p>A method that allows you transform the key that is used for caching, if you want to use something other than the pure arguments.</p>
				<pre><code class="language-ts"><span class="hljs-keyword">const</span> ignoreFunctionArgs = <span class="hljs-function">(<span class="hljs-params">one: <span class="hljs-built_in">string</span>, two: () =&gt; {}</span>) =&gt;</span> [one, two];

<span class="hljs-keyword">const</span> memoized = memoize(ignoreFunctionArgs, {
  <span class="hljs-attr">transformKey</span>: <span class="hljs-built_in">JSON</span>.stringify
});

<span class="hljs-built_in">console</span>.log(memoized(<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-function">() =&gt;</span> {})); <span class="hljs-comment">// [&#x27;one&#x27;, () =&gt; {}]</span>
<span class="hljs-built_in">console</span>.log(memoized(<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-function">() =&gt;</span> {})); <span class="hljs-comment">// pulled from cache, [&#x27;one&#x27;, () =&gt; {}]</span></code></pre>
				<p>If your transformed keys require something other than <code>SameValueZero</code> equality, you can combine <code>transformKey</code> with <a href="#isequal"><code>isEqual</code></a> for completely custom key creation and comparison.</p>
				<pre><code class="language-ts"><span class="hljs-keyword">const</span> ignoreFunctionArgs = <span class="hljs-function">(<span class="hljs-params">one: <span class="hljs-built_in">string</span>, two: () =&gt; {}</span>) =&gt;</span> [one, two];

<span class="hljs-keyword">const</span> memoized = memoize(ignoreFunctionArgs, {
  <span class="hljs-function"><span class="hljs-title">isEqual</span>(<span class="hljs-params">key1: <span class="hljs-built_in">string</span>, key2: <span class="hljs-built_in">string</span></span>)</span> {
    <span class="hljs-keyword">return</span> key1.args === key2.args;
  },
  <span class="hljs-function"><span class="hljs-title">transformKey</span>(<span class="hljs-params">args: <span class="hljs-built_in">any</span>[]</span>)</span> {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">args</span>: <span class="hljs-built_in">JSON</span>.stringify(args)
    };
  }
});

<span class="hljs-built_in">console</span>.log(memoized(<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-function">() =&gt;</span> {})); <span class="hljs-comment">// [&#x27;one&#x27;, () =&gt; {}]</span>
<span class="hljs-built_in">console</span>.log(memoized(<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-function">() =&gt;</span> {})); <span class="hljs-comment">// pulled from cache, [&#x27;one&#x27;, () =&gt; {}]</span></code></pre>
				<a href="#additional-properties" id="additional-properties" style="color: inherit; text-decoration: none;">
					<h2>Additional properties</h2>
				</a>
				<a href="#memoizedcache" id="memoizedcache" style="color: inherit; text-decoration: none;">
					<h3>memoized.cache</h3>
				</a>
				<p><code>Object</code></p>
				<p>The <code>cache</code> object that is used internally. The shape of this structure:</p>
				<pre><code class="language-ts">{
  <span class="hljs-attr">keys</span>: <span class="hljs-built_in">any</span>[][], <span class="hljs-comment">// available as MicroMemoize.Key[]</span>
  <span class="hljs-attr">values</span>: <span class="hljs-built_in">any</span>[] <span class="hljs-comment">// available as MicroMemoize.Value[]</span>
}</code></pre>
				<p>The exposure of this object is to allow for manual manipulation of keys/values (injection, removal, expiration, etc).</p>
				<pre><code class="language-ts"><span class="hljs-keyword">const</span> method = <span class="hljs-function">(<span class="hljs-params">one: <span class="hljs-built_in">string</span>, two: <span class="hljs-built_in">string</span></span>) =&gt;</span> ({ one, two });

<span class="hljs-keyword">const</span> memoized = memoize(method);

memoized.cache.keys.push([<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>]);
memoized.cache.values.push(<span class="hljs-string">&quot;cached&quot;</span>);

<span class="hljs-built_in">console</span>.log(memoized(<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>)); <span class="hljs-comment">// &#x27;cached&#x27;</span></code></pre>
				<p><strong>NOTE</strong>: <code>moize</code> offers a variety of convenience methods for this manual <code>cache</code> manipulation, and while <code>micro-memoize</code> allows all the same capabilities by exposing the <code>cache</code>, it does not provide any convenience methods.</p>
				<a href="#memoizedcachesnapshot" id="memoizedcachesnapshot" style="color: inherit; text-decoration: none;">
					<h4>memoized.cache.snapshot</h4>
				</a>
				<p><code>Object</code></p>
				<p>This is identical to the <code>cache</code> object referenced above, but it is a deep clone created at request, which will provide a persistent snapshot of the values at that time. This is useful when tracking the cache changes over time, as the <code>cache</code> object is mutated internally for performance reasons.</p>
				<a href="#memoizedfn" id="memoizedfn" style="color: inherit; text-decoration: none;">
					<h3>memoized.fn</h3>
				</a>
				<p><code>function</code></p>
				<p>The original function passed to be memoized.</p>
				<a href="#memoizedismemoized" id="memoizedismemoized" style="color: inherit; text-decoration: none;">
					<h3>memoized.isMemoized</h3>
				</a>
				<p><code>boolean</code></p>
				<p>Hard-coded to <code>true</code> when the function is memoized. This is useful for introspection, to identify if a method has been memoized or not.</p>
				<a href="#memoizedoptions" id="memoizedoptions" style="color: inherit; text-decoration: none;">
					<h3>memoized.options</h3>
				</a>
				<p><code>Object</code></p>
				<p>The <a href="#options"><code>options</code></a> passed when creating the memoized method.</p>
				<a href="#benchmarks" id="benchmarks" style="color: inherit; text-decoration: none;">
					<h2>Benchmarks</h2>
				</a>
				<p>All values provided are the number of operations per second (ops/sec) calculated by the <a href="https://benchmarkjs.com/">Benchmark suite</a>. Note that <code>underscore</code>, <code>lodash</code>, and <code>ramda</code> do not support mulitple-parameter memoization (which is where <code>micro-memoize</code> really shines), so they are not included in those benchmarks.</p>
				<p>Benchmarks was performed on an i7 8-core Arch Linux laptop with 16GB of memory using NodeJS version <code>10.15.0</code>. The default configuration of each library was tested with a fibonacci calculation based on the following parameters:</p>
				<ul>
					<li>Single primitive = <code>35</code></li>
					<li>Single object = <code>{number: 35}</code></li>
					<li>Multiple primitives = <code>35, true</code></li>
					<li>Multiple objects = <code>{number: 35}, {isComplete: true}</code></li>
				</ul>
				<p><strong>NOTE</strong>: Not all libraries tested support multiple parameters out of the box, but support the ability to pass a custom <code>resolver</code>. Because these often need to resolve to a string value, <a href="https://github.com/lodash/lodash/issues/2115">a common suggestion</a> is to just <code>JSON.stringify</code> the arguments, so that is what is used when needed.</p>
				<a href="#single-parameter-primitive-only" id="single-parameter-primitive-only" style="color: inherit; text-decoration: none;">
					<h3>Single parameter (primitive only)</h3>
				</a>
				<p>This is usually what benchmarks target for ... its the least-likely use-case, but the easiest to optimize, often at the expense of more common use-cases.</p>
				<table>
					<thead>
						<tr>
							<th></th>
							<th>Operations / second</th>
						</tr>
					</thead>
					<tbody><tr>
							<td>fast-memoize</td>
							<td>59,069,204</td>
						</tr>
						<tr>
							<td><strong>micro-memoize</strong></td>
							<td><strong>48,267,295</strong></td>
						</tr>
						<tr>
							<td>lru-memoize</td>
							<td>46,781,143</td>
						</tr>
						<tr>
							<td>Addy Osmani</td>
							<td>32,372,414</td>
						</tr>
						<tr>
							<td>lodash</td>
							<td>29,297,916</td>
						</tr>
						<tr>
							<td>ramda</td>
							<td>25,054,838</td>
						</tr>
						<tr>
							<td>mem</td>
							<td>24,848,072</td>
						</tr>
						<tr>
							<td>underscore</td>
							<td>24,847,818</td>
						</tr>
						<tr>
							<td>memoizee</td>
							<td>18,272,987</td>
						</tr>
						<tr>
							<td>memoizerific</td>
							<td>7,302,835</td>
						</tr>
				</tbody></table>
				<a href="#single-parameter-complex-object" id="single-parameter-complex-object" style="color: inherit; text-decoration: none;">
					<h3>Single parameter (complex object)</h3>
				</a>
				<p>This is what most memoization libraries target as the primary use-case, as it removes the complexities of multiple arguments but allows for usage with one to many values.</p>
				<table>
					<thead>
						<tr>
							<th></th>
							<th>Operations / second</th>
						</tr>
					</thead>
					<tbody><tr>
							<td><strong>micro-memoize</strong></td>
							<td><strong>40,360,621</strong></td>
						</tr>
						<tr>
							<td>lodash</td>
							<td>30,862,028</td>
						</tr>
						<tr>
							<td>lru-memoize</td>
							<td>25,740,572</td>
						</tr>
						<tr>
							<td>memoizee</td>
							<td>12,058,375</td>
						</tr>
						<tr>
							<td>memoizerific</td>
							<td>6,854,855</td>
						</tr>
						<tr>
							<td>ramda</td>
							<td>2,287,030</td>
						</tr>
						<tr>
							<td>underscore</td>
							<td>2,270,574</td>
						</tr>
						<tr>
							<td>Addy Osmani</td>
							<td>2,076,031</td>
						</tr>
						<tr>
							<td>mem</td>
							<td>2,001,984</td>
						</tr>
						<tr>
							<td>fast-memoize</td>
							<td>1,591,019</td>
						</tr>
				</tbody></table>
				<a href="#multiple-parameters-primitives-only" id="multiple-parameters-primitives-only" style="color: inherit; text-decoration: none;">
					<h3>Multiple parameters (primitives only)</h3>
				</a>
				<p>This is a very common use-case for function calls, but can be more difficult to optimize because you need to account for multiple possibilities ... did the number of arguments change, are there default arguments, etc.</p>
				<table>
					<thead>
						<tr>
							<th></th>
							<th>Operations / second</th>
						</tr>
					</thead>
					<tbody><tr>
							<td><strong>micro-memoize</strong></td>
							<td><strong>33,546,353</strong></td>
						</tr>
						<tr>
							<td>lru-memoize</td>
							<td>20,884,669</td>
						</tr>
						<tr>
							<td>memoizee</td>
							<td>7,831,161</td>
						</tr>
						<tr>
							<td>Addy Osmani</td>
							<td>6,447,448</td>
						</tr>
						<tr>
							<td>memoizerific</td>
							<td>5,587,779</td>
						</tr>
						<tr>
							<td>mem</td>
							<td>2,620,943</td>
						</tr>
						<tr>
							<td>underscore</td>
							<td>1,617,687</td>
						</tr>
						<tr>
							<td>ramda</td>
							<td>1,569,167</td>
						</tr>
						<tr>
							<td>lodash</td>
							<td>1,512,515</td>
						</tr>
						<tr>
							<td>fast-memoize</td>
							<td>1,376,665</td>
						</tr>
				</tbody></table>
				<a href="#multiple-parameters-complex-objects" id="multiple-parameters-complex-objects" style="color: inherit; text-decoration: none;">
					<h3>Multiple parameters (complex objects)</h3>
				</a>
				<p>This is the most robust use-case, with the same complexities as multiple primitives but managing bulkier objects with additional edge scenarios (destructured with defaults, for example).</p>
				<table>
					<thead>
						<tr>
							<th></th>
							<th>Operations / second</th>
						</tr>
					</thead>
					<tbody><tr>
							<td><strong>micro-memoize</strong></td>
							<td><strong>34,857,438</strong></td>
						</tr>
						<tr>
							<td>lru-memoize</td>
							<td>20,838,330</td>
						</tr>
						<tr>
							<td>memoizee</td>
							<td>7,820,066</td>
						</tr>
						<tr>
							<td>memoizerific</td>
							<td>5,761,357</td>
						</tr>
						<tr>
							<td>mem</td>
							<td>1,184,550</td>
						</tr>
						<tr>
							<td>ramda</td>
							<td>1,034,937</td>
						</tr>
						<tr>
							<td>underscore</td>
							<td>1,021,480</td>
						</tr>
						<tr>
							<td>Addy Osmani</td>
							<td>1,014,642</td>
						</tr>
						<tr>
							<td>lodash</td>
							<td>1,014,060</td>
						</tr>
						<tr>
							<td>fast-memoize</td>
							<td>949,213</td>
						</tr>
				</tbody></table>
				<a href="#browser-support" id="browser-support" style="color: inherit; text-decoration: none;">
					<h2>Browser support</h2>
				</a>
				<ul>
					<li>Chrome (all versions)</li>
					<li>Firefox (all versions)</li>
					<li>Edge (all versions)</li>
					<li>Opera 15+</li>
					<li>IE 9+</li>
					<li>Safari 6+</li>
					<li>iOS 8+</li>
					<li>Android 4+</li>
				</ul>
				<a href="#node-support" id="node-support" style="color: inherit; text-decoration: none;">
					<h2>Node support</h2>
				</a>
				<ul>
					<li>4+</li>
				</ul>
				<a href="#development" id="development" style="color: inherit; text-decoration: none;">
					<h2>Development</h2>
				</a>
				<p>Standard stuff, clone the repo and <code>npm install</code> dependencies. The npm scripts available:</p>
				<ul>
					<li><code>build</code> =&gt; run webpack to build development <code>dist</code> file with NODE_ENV=development</li>
					<li><code>build:minifed</code> =&gt; run webpack to build production <code>dist</code> file with NODE_ENV=production</li>
					<li><code>dev</code> =&gt; run webpack dev server to run example app (playground!)</li>
					<li><code>dist</code> =&gt; runs <code>build</code> and <code>build-minified</code></li>
					<li><code>lint</code> =&gt; run ESLint against all files in the <code>src</code> folder</li>
					<li><code>prepublish</code> =&gt; runs <code>compile-for-publish</code></li>
					<li><code>prepublish:compile</code> =&gt; run <code>lint</code>, <code>test</code>, <code>transpile:es</code>, <code>transpile:lib</code>, <code>dist</code></li>
					<li><code>test</code> =&gt; run AVA test functions with <code>NODE_ENV=test</code></li>
					<li><code>test:coverage</code> =&gt; run <code>test</code> but with <code>nyc</code> for coverage checker</li>
					<li><code>test:watch</code> =&gt; run <code>test</code>, but with persistent watcher</li>
					<li><code>transpile:lib</code> =&gt; run babel against all files in <code>src</code> to create files in <code>lib</code></li>
					<li><code>transpile:es</code> =&gt; run babel against all files in <code>src</code> to create files in <code>es</code>, preserving ES2015 modules (for <a href="https://github.com/rollup/rollup/wiki/pkg.module"><code>pkg.module</code></a>)</li>
				</ul>
			</div>
		</div>
		<div class="col-4 col-menu menu-sticky-wrap menu-highlight">
			<nav class="tsd-navigation primary">
				<ul>
					<li class="globals  ">
						<a href="globals.html"><em>Globals</em></a>
					</li>
					<li class="label tsd-is-external">
						<span>Externals</span>
					</li>
					<li class=" tsd-kind-namespace tsd-is-external">
						<a href="modules/micromemoize.html">Micro<wbr>Memoize</a>
					</li>
				</ul>
			</nav>
			<nav class="tsd-navigation secondary menu-sticky">
				<ul class="before-current">
					<li class=" tsd-kind-class tsd-is-external">
						<a href="classes/cache.html" class="tsd-kind-icon">Cache</a>
					</li>
					<li class=" tsd-kind-interface tsd-has-type-parameter">
						<a href="interfaces/maxage.html" class="tsd-kind-icon">Max<wbr>Age</a>
					</li>
					<li class=" tsd-kind-interface tsd-has-type-parameter">
						<a href="interfaces/moize.html" class="tsd-kind-icon">Moize</a>
					</li>
					<li class=" tsd-kind-type-alias tsd-has-type-parameter">
						<a href="globals.html#curriedmoize" class="tsd-kind-icon">Curried<wbr>Moize</a>
					</li>
					<li class=" tsd-kind-type-alias tsd-has-type-parameter tsd-is-external">
						<a href="globals.html#dictionary" class="tsd-kind-icon">Dictionary</a>
					</li>
					<li class=" tsd-kind-type-alias">
						<a href="globals.html#expiration" class="tsd-kind-icon">Expiration</a>
					</li>
					<li class=" tsd-kind-type-alias tsd-has-type-parameter">
						<a href="globals.html#fn" class="tsd-kind-icon">Fn</a>
					</li>
					<li class=" tsd-kind-type-alias tsd-has-type-parameter">
						<a href="globals.html#functionalcomponent" class="tsd-kind-icon">Functional<wbr>Component</a>
					</li>
					<li class=" tsd-kind-type-alias">
						<a href="globals.html#globalstatsobject" class="tsd-kind-icon">Global<wbr>Stats<wbr>Object</a>
					</li>
					<li class=" tsd-kind-type-alias">
						<a href="globals.html#isequal" class="tsd-kind-icon">Is<wbr>Equal</a>
					</li>
					<li class=" tsd-kind-type-alias">
						<a href="globals.html#ismatchingkey" class="tsd-kind-icon">Is<wbr>Matching<wbr>Key</a>
					</li>
					<li class=" tsd-kind-type-alias tsd-has-type-parameter">
						<a href="globals.html#key" class="tsd-kind-icon">Key</a>
					</li>
					<li class=" tsd-kind-type-alias tsd-has-type-parameter">
						<a href="globals.html#memoized" class="tsd-kind-icon">Memoized</a>
					</li>
					<li class=" tsd-kind-type-alias">
						<a href="globals.html#micromemoizeoptions" class="tsd-kind-icon">Micro<wbr>Memoize<wbr>Options</a>
					</li>
					<li class=" tsd-kind-type-alias tsd-has-type-parameter">
						<a href="globals.html#moizeconfiguration" class="tsd-kind-icon">Moize<wbr>Configuration</a>
					</li>
					<li class=" tsd-kind-type-alias">
						<a href="globals.html#moizeable" class="tsd-kind-icon">Moizeable</a>
					</li>
					<li class=" tsd-kind-type-alias tsd-has-type-parameter">
						<a href="globals.html#moized" class="tsd-kind-icon">Moized</a>
					</li>
					<li class=" tsd-kind-type-alias">
						<a href="globals.html#oncacheoperation" class="tsd-kind-icon">On<wbr>Cache<wbr>Operation</a>
					</li>
					<li class=" tsd-kind-type-alias">
						<a href="globals.html#onexpire" class="tsd-kind-icon">On<wbr>Expire</a>
					</li>
					<li class=" tsd-kind-type-alias">
						<a href="globals.html#options" class="tsd-kind-icon">Options</a>
					</li>
					<li class=" tsd-kind-type-alias">
						<a href="globals.html#serialize" class="tsd-kind-icon">Serialize</a>
					</li>
					<li class=" tsd-kind-type-alias">
						<a href="globals.html#statscache" class="tsd-kind-icon">Stats<wbr>Cache</a>
					</li>
					<li class=" tsd-kind-type-alias">
						<a href="globals.html#statsobject" class="tsd-kind-icon">Stats<wbr>Object</a>
					</li>
					<li class=" tsd-kind-type-alias">
						<a href="globals.html#statsprofile" class="tsd-kind-icon">Stats<wbr>Profile</a>
					</li>
					<li class=" tsd-kind-type-alias">
						<a href="globals.html#transformkey" class="tsd-kind-icon">Transform<wbr>Key</a>
					</li>
					<li class=" tsd-kind-type-alias">
						<a href="globals.html#updatecacheforkey" class="tsd-kind-icon">Update<wbr>Cache<wbr>For<wbr>Key</a>
					</li>
					<li class=" tsd-kind-type-alias">
						<a href="globals.html#value" class="tsd-kind-icon">Value</a>
					</li>
					<li class=" tsd-kind-variable">
						<a href="globals.html#react_element_type" class="tsd-kind-icon">REACT_<wbr>ELEMENT_<wbr>TYPE</a>
					</li>
					<li class=" tsd-kind-variable">
						<a href="globals.html#haswarningdisplayed" class="tsd-kind-icon">has<wbr>Warning<wbr>Displayed</a>
					</li>
					<li class=" tsd-kind-variable tsd-is-external">
						<a href="globals.html#slice" class="tsd-kind-icon">slice</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter tsd-is-private">
						<a href="globals.html#addinstancemethods" class="tsd-kind-icon">add<wbr>Instance<wbr>Methods</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter tsd-is-private">
						<a href="globals.html#addinstanceproperties" class="tsd-kind-icon">add<wbr>Instance<wbr>Properties</a>
					</li>
					<li class=" tsd-kind-function tsd-is-private">
						<a href="globals.html#clearexpiration" class="tsd-kind-icon">clear<wbr>Expiration</a>
					</li>
					<li class=" tsd-kind-function">
						<a href="globals.html#clearstats" class="tsd-kind-icon">clear<wbr>Stats</a>
					</li>
					<li class=" tsd-kind-function tsd-is-external">
						<a href="globals.html#clonearray" class="tsd-kind-icon">clone<wbr>Array</a>
					</li>
					<li class=" tsd-kind-function tsd-is-private">
						<a href="globals.html#collectstats" class="tsd-kind-icon">collect<wbr>Stats</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter tsd-is-private">
						<a href="globals.html#combine" class="tsd-kind-icon">combine</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter tsd-is-private">
						<a href="globals.html#compose" class="tsd-kind-icon">compose</a>
					</li>
					<li class=" tsd-kind-function tsd-is-private">
						<a href="globals.html#copystaticproperties" class="tsd-kind-icon">copy<wbr>Static<wbr>Properties</a>
					</li>
					<li class=" tsd-kind-function tsd-is-private">
						<a href="globals.html#createdefaultreplacer" class="tsd-kind-icon">create<wbr>Default<wbr>Replacer</a>
					</li>
					<li class=" tsd-kind-function tsd-is-private">
						<a href="globals.html#createfindkeyindex" class="tsd-kind-icon">create<wbr>Find<wbr>Key<wbr>Index</a>
					</li>
					<li class=" tsd-kind-function">
						<a href="globals.html#creategetinitialargs" class="tsd-kind-icon">create<wbr>Get<wbr>Initial<wbr>Args</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter tsd-is-private">
						<a href="globals.html#createmoizeinstance" class="tsd-kind-icon">create<wbr>Moize<wbr>Instance</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter tsd-is-private">
						<a href="globals.html#createmoizedcomponent" class="tsd-kind-icon">create<wbr>Moized<wbr>Component</a>
					</li>
					<li class=" tsd-kind-function tsd-is-private">
						<a href="globals.html#createoncacheaddincrementcalls" class="tsd-kind-icon">create<wbr>OnCache<wbr>Add<wbr>Increment<wbr>Calls</a>
					</li>
					<li class=" tsd-kind-function tsd-is-private">
						<a href="globals.html#createoncacheaddsetexpiration" class="tsd-kind-icon">create<wbr>OnCache<wbr>Add<wbr>Set<wbr>Expiration</a>
					</li>
					<li class=" tsd-kind-function tsd-is-private">
						<a href="globals.html#createoncachehitincrementcallsandhits" class="tsd-kind-icon">create<wbr>OnCache<wbr>Hit<wbr>Increment<wbr>Calls<wbr>And<wbr>Hits</a>
					</li>
					<li class=" tsd-kind-function tsd-is-private">
						<a href="globals.html#createoncachehitresetexpiration" class="tsd-kind-icon">create<wbr>OnCache<wbr>Hit<wbr>Reset<wbr>Expiration</a>
					</li>
					<li class=" tsd-kind-function">
						<a href="globals.html#createoncacheoperation" class="tsd-kind-icon">create<wbr>OnCache<wbr>Operation</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#createrefreshablemoized" class="tsd-kind-icon">create<wbr>Refreshable<wbr>Moized</a>
					</li>
					<li class=" tsd-kind-function tsd-is-private">
						<a href="globals.html#createtimeout" class="tsd-kind-icon">create<wbr>Timeout</a>
					</li>
					<li class=" tsd-kind-function tsd-is-private">
						<a href="globals.html#defaultargumentserializer" class="tsd-kind-icon">default<wbr>Argument<wbr>Serializer</a>
					</li>
					<li class=" tsd-kind-function tsd-is-private">
						<a href="globals.html#findexpirationindex" class="tsd-kind-icon">find<wbr>Expiration<wbr>Index</a>
					</li>
					<li class=" tsd-kind-function tsd-is-external">
						<a href="globals.html#getcustomoptions" class="tsd-kind-icon">get<wbr>Custom<wbr>Options</a>
					</li>
					<li class=" tsd-kind-function">
						<a href="globals.html#getcutoff" class="tsd-kind-icon">get<wbr>Cutoff</a>
					</li>
					<li class=" tsd-kind-function tsd-is-private">
						<a href="globals.html#getdefaultprofilename" class="tsd-kind-icon">get<wbr>Default<wbr>Profile<wbr>Name</a>
					</li>
					<li class=" tsd-kind-function tsd-is-private">
						<a href="globals.html#getisequal" class="tsd-kind-icon">get<wbr>IsEqual</a>
					</li>
					<li class=" tsd-kind-function tsd-is-private">
						<a href="globals.html#getismatchingkey" class="tsd-kind-icon">get<wbr>IsMatching<wbr>Key</a>
					</li>
					<li class=" tsd-kind-function tsd-is-private">
						<a href="globals.html#getisserializedkeyequal" class="tsd-kind-icon">get<wbr>IsSerialized<wbr>Key<wbr>Equal</a>
					</li>
					<li class=" tsd-kind-function tsd-is-private">
						<a href="globals.html#getmaxageoptions" class="tsd-kind-icon">get<wbr>Max<wbr>Age<wbr>Options</a>
					</li>
					<li class=" tsd-kind-function tsd-is-private">
						<a href="globals.html#getserializerfunction" class="tsd-kind-icon">get<wbr>Serializer<wbr>Function</a>
					</li>
					<li class=" tsd-kind-function tsd-is-private">
						<a href="globals.html#getstats" class="tsd-kind-icon">get<wbr>Stats</a>
					</li>
					<li class=" tsd-kind-function tsd-is-private">
						<a href="globals.html#getstatsoptions" class="tsd-kind-icon">get<wbr>Stats<wbr>Options</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter tsd-is-private">
						<a href="globals.html#getstringifiedargument" class="tsd-kind-icon">get<wbr>Stringified<wbr>Argument</a>
					</li>
					<li class=" tsd-kind-function tsd-is-private">
						<a href="globals.html#gettransformkey" class="tsd-kind-icon">get<wbr>Transform<wbr>Key</a>
					</li>
					<li class=" tsd-kind-function tsd-is-private">
						<a href="globals.html#getusagepercentage" class="tsd-kind-icon">get<wbr>Usage<wbr>Percentage</a>
					</li>
					<li class=" tsd-kind-function tsd-is-external">
						<a href="globals.html#ismemoized" class="tsd-kind-icon">is<wbr>Memoized</a>
					</li>
					<li class=" tsd-kind-function">
						<a href="globals.html#ismoized" class="tsd-kind-icon">is<wbr>Moized</a>
					</li>
					<li class=" tsd-kind-function tsd-is-external">
						<a href="globals.html#issamevaluezero" class="tsd-kind-icon">is<wbr>Same<wbr>Value<wbr>Zero</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#maxage" class="tsd-kind-icon">max<wbr>Age</a>
					</li>
					<li class=" tsd-kind-function tsd-is-private tsd-is-external">
						<a href="globals.html#mergeoptions" class="tsd-kind-icon">merge<wbr>Options</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#moize" class="tsd-kind-icon">moize</a>
					</li>
					<li class=" tsd-kind-object-literal">
						<a href="globals.html#always_skipped_properties" class="tsd-kind-icon">ALWAYS_<wbr>SKIPPED_<wbr>PROPERTIES</a>
					</li>
					<li class=" tsd-kind-object-literal tsd-is-private">
						<a href="globals.html#default_options" class="tsd-kind-icon">DEFAULT_<wbr>OPTIONS</a>
					</li>
					<li class=" tsd-kind-object-literal tsd-is-external">
						<a href="globals.html#default_options_keys" class="tsd-kind-icon">DEFAULT_<wbr>OPTIONS_<wbr>KEYS</a>
					</li>
					<li class=" tsd-kind-object-literal">
						<a href="globals.html#statscache" class="tsd-kind-icon">stats<wbr>Cache</a>
					</li>
				</ul>
			</nav>
		</div>
	</div>
</div>
<footer class="with-border-bottom">
	<div class="container">
		<h2>Legend</h2>
		<div class="tsd-legend-group">
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-interface"><span class="tsd-kind-icon">Property</span></li>
			</ul>
		</div>
	</div>
</footer>
<div class="container tsd-generator">
	<p>Generated using <a href="https://typedoc.org/" target="_blank">TypeDoc</a></p>
</div>
<div class="overlay"></div>
<script src="assets/js/main.js"></script>
</body>
</html>