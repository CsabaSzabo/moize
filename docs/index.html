<!DOCTYPE html>

<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width">
	<title>moize Index</title>

	<!--[if lt IE 9]>
	<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	<link type="text/css" rel="stylesheet" href="styles/sunlight.dark.css">

	<link type="text/css" rel="stylesheet" href="styles/site.paper.css">

</head>

<body>

<div class="navbar navbar-default navbar-fixed-top ">
<div class="container">
	<div class="navbar-header">
		<a class="navbar-brand" href="index.html">moize</a>
		<button class="navbar-toggle" type="button" data-toggle="collapse" data-target="#topNavigation">
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
        </button>
	</div>
	<div class="navbar-collapse collapse" id="topNavigation">
		<ul class="nav navbar-nav">
			
			<li class="dropdown">
				<a href="modules.list.html" class="dropdown-toggle" data-toggle="dropdown">Modules<b class="caret"></b></a>
				<ul class="dropdown-menu inline">
					<li><a href="module-moize.html">moize</a></li>
				</ul>
			</li>
			
		</ul>
        
            <div class="col-sm-3 col-md-3">
                <form class="navbar-form" role="search">
                    <div class="input-group">
                        <input type="text" class="form-control" placeholder="Search" name="q" id="search-input">
                        <div class="input-group-btn">
                            <button class="btn btn-default" id="search-submit"><i class="glyphicon glyphicon-search"></i></button>
                        </div>
                    </div>
                </form>
            </div>
        
	</div>

</div>
</div>


<div class="container" id="toc-content">
<div class="row">

	
	<div class="col-md-8">
	
		<div id="main">
			

	
	



    <h3>moize 2.0.0</h3>









	
	





    <section class="readme-section">
        <article><h1 id="moize">moize</h1>
<p><img src="https://img.shields.io/badge/build-passing-brightgreen.svg"/>
<img src="https://img.shields.io/badge/coverage-98.63%25-brightgreen.svg"/>
<img src="https://img.shields.io/badge/license-MIT-blue.svg"/></p>
<p><code>moize</code> is a <a href="#benchmarks">blazing fast</a> memoization library for JavaScript. It handles multiple arguments out of the box, and also offers options to help satisfy a number of implementation-specific needs. It has no dependencies, and is about 2.7kb when minified and gzipped.</p>
<h3 id="table-of-contents">Table of contents</h3>
<ul>
<li><a href="#installation">Installation</a></li>
<li><a href="#usage">Usage</a></li>
<li><a href="#usage-with-functional-react-components">Usage with functional React components</a></li>
<li><a href="#advanced-usage">Advanced usage</a></li>
<li><a href="#direct-cache-manipulation">Direct cache manipulation</a></li>
<li><a href="#benchmarks">Benchmarks</a></li>
<li><a href="#browser-support">Browser support</a></li>
<li><a href="#development">Development</a></li>
</ul>
<h3 id="installation">Installation</h3>
<pre class="prettyprint source"><code>$ npm i moize --save</code></pre><h3 id="usage">Usage</h3>
<pre class="prettyprint source lang-javascript"><code>import moize from 'moize';

const method = (a, b) => {
  return a + b;
};

const memoized = moize(method);

memoized(2, 4); // 6
memoized(2, 4); // 6, pulled from cache</code></pre><p>All parameter types are supported, including circular objects, functions, etc. You can even memoize functional <code>React</code> components based on their <code>props</code> + <code>context</code> combination!</p>
<h3 id="usage-with-functional-react-components">Usage with functional React components</h3>
<p>Now in v2.x.x of <code>moize</code> you have a quick shortcut for memoizing functional components in <a href="https://github.com/facebook/react">React</a>:</p>
<pre class="prettyprint source lang-javascript"><code>import moize from 'moize';

const Foo = ({bar, baz}) => {
  return (
    &lt;div>
      {bar} {baz}
    &lt;/div>
  );
};

export default moize.react(Foo);</code></pre><p><code>moize.react</code> will auto-apply the <code>serialize</code> and <code>serializeFunctions</code> options to <code>true</code>, which allows for a value equality comparison of <code>props</code> and <code>context</code>. You can still pass additional options in the same way you pass them in the default <code>moize</code> method. Please note this will not operate with components made via the <code>class</code> instantiation.</p>
<h3 id="advanced-usage">Advanced usage</h3>
<p><code>moize</code> optionally accepts an object of options as the second parameter. The full shape of these options:</p>
<pre class="prettyprint source lang-javascript"><code>{
  cache: Map|Object, // custom cache implementation
  isPromise: boolean, // is the result a promise
  maxAge: number, // amount of time in milliseconds before the cache will expire
  maxArgs: number, // maximum number of arguments to use as key for caching
  maxSize: number, // maximum size of cache for this method
  serialize: boolean, // should the parameters be serialized instead of directly referenced
  serializeFunctions: boolean, // should functions be included in the serialization of multiple parameters
  serializer: Function // method to serialize the arguments to build a unique cache key
}</code></pre><p><strong>cache</strong> <em>defaults to new Map()</em></p>
<p>The default cache implementation is build for speed in its purpose, however if you would like then you can pass in a custom cache implementation. The only requirements for the cache implementation is that it matches the relevant <code>Map</code> API methods:</p>
<ul>
<li>clear</li>
<li>delete</li>
<li>get</li>
<li>has</li>
<li>set</li>
</ul>
<pre class="prettyprint source lang-javascript"><code>const cache = {
  clear() {
    Object.keys(this).forEach((key) => {
      if (typeof this[key] !== 'function') {
        this.delete(key);
      }
    });
  },
  delete(key) {
    delete this[key];
  },
  get(key) {
    return this[key];
  },
  has(key) {
    return this.hasOwnProperty[key];
  },
  set(key, value) {
    this[key] = value;

    return this;
  }
};
const fn = (item) => {
  return item;
};

const memoized = moize(fn, {
  cache
});</code></pre><p><strong>isPromise</strong> <em>defaults to false</em></p>
<p>Is the computed value in the function a <code>Promise</code>, and should we cache the resolved value from that <code>Promise</code>.</p>
<pre class="prettyprint source lang-javascript"><code>const fn = async (item) => {
  return await item;
};

const memoized = moize(fn, {
  isPromise: true
});</code></pre><p><strong>maxAge</strong> <em>defaults to Infinity</em></p>
<p>The maximum amount of time in milliseconds that you want a computed value to be stored in cache for this method.</p>
<pre class="prettyprint source lang-javascript"><code>const fn = (item) => {
  return item;
};

const memoized = moize(fn, {
  maxAge: 1000 * 60 * 5 // five minutes
});</code></pre><p><strong>maxArgs</strong> <em>defaults to the length of arguments passed to the method</em></p>
<p>The maximum number of arguments used in creating the key for the cache.</p>
<pre class="prettyprint source lang-javascript"><code>const fn = (item1, item2, item3) => {
  return item1 + item2 + item3;
};

const memoized = moize(fn, {
  maxArgs: 2
});</code></pre><p><strong>maxSize</strong> <em>defaults to Infinity</em></p>
<p>The maximum size of the cache you want stored in cache for this method. Clearance of the cache once the <code>maxSize</code> is reached is on a <a href="https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_Recently_Used_.28LRU.29">Least Recently Used</a> basis.</p>
<pre class="prettyprint source lang-javascript"><code>const fn = (item) => {
  return item;
};

const memoized = moize(fn, {
  maxSize: 5
});</code></pre><p><strong>serialize</strong> <em>defaults to false</em></p>
<p>In <code>moize</code> v1.x.x, parameter serialization was used, whereas in v2.x.x and beyond we use strict equality to compare parameters. While this is both faster and more accurate, there may be scenarios where you want to serialize the parameters instead (for value equality comparison in situations where you are using mutated objects, for example). Simply pass the <code>serialize</code> parameter as <code>true</code> and you will use the performant serializer from v1.x.x.</p>
<pre class="prettyprint source lang-javascript"><code>const fn = (mutableObject) => {
  return mutableObject.foo;
};

const memoized = moize(fn, {
  serialize: true
});

const object = {
  foo: 'foo'
};

memoized(object); // 'foo'

object.foo = 'bar';

memoized(object); // 'bar'</code></pre><p><strong>serializeFunctions</strong> <em>defaults to false</em></p>
<p>By setting this option to <code>true</code>, a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify">custom replacer</a> will be used to ensure functions are included in the key serialization. This is especially beneficial when caching functional <code>React</code> components, as interactivity functions as part of props will now be included in the unique key structure (in fact, this is exactly how <code>moize.react</code> works!). Please note that this will decrease performance of this specific function between 10-25% depending on environment.</p>
<pre class="prettyprint source lang-javascript"><code>const FunctionalComponent = ({onClickFoo}) => {
  return (
    &lt;button
      onClick={onClickFoo}
      type=&quot;button&quot;
    >
      Click me!
    &lt;/button>
  )
};

const MemoizedFunctionalComponent = moize(FunctionalComponent, {
  serializeFunctions: true
});</code></pre><p>Please note that you must also set <code>serialize</code> to true for this setting to take effect.</p>
<p><strong>serializer</strong> <em>defaults to serializeArguments in utils.js</em></p>
<p>The default seralizer method is highly performant, and covers a number of edge cases (recursive objects, for example), however if you want to provide a custom one you may. The value returned from the function must be a valid value of keys for a <code>Map</code>.</p>
<pre class="prettyprint source lang-javascript"><code>const serializer = (args) => {
  return JSON.stringify(args[0]);
};

const memoized = moize(fn, {
  serializer
});</code></pre><p>Please note that you must also set <code>serialize</code> to true for this setting to take effect.</p>
<h3 id="direct-cache-manipulation">Direct cache manipulation</h3>
<p>There are a couple of methods provided on the memoized function which allow for programmatic manipulation of the cache:</p>
<p><strong>clear()</strong></p>
<p>This will clear all values in the cache, resetting it to a default state.</p>
<pre class="prettyprint source lang-javascript"><code>const memoized = moize((item) => {
  return item;
});

memoized.clear();</code></pre><p><strong>delete(key)</strong></p>
<p>This will delete the provided key from cache.</p>
<pre class="prettyprint source lang-javascript"><code>// if single parameter, delete with the object itself
const memoized = moize((item) => {
  return item;
});

const foo = {
  bar: 'baz'
};

memoized(foo);

memoized.delete(foo);

// if multi parameter, delete with the same arguments you passed
const memoized = moize((item1, item2) => {
  return item1 + item2;
});

const foo = 1;
const bar = 2;

memoized(foo, bar);

memoized.delete(foo, bar);</code></pre><p><strong>keys()</strong></p>
<p>This will return a list of the current keys in cache.</p>
<pre class="prettyprint source lang-javascript"><code>const memoized = moize((item) => {
  return item;
});

const foo = 'foo';

memoized(foo);

const bar = {
  baz: 'baz'
};

memoized(bar);

const keys = memoized.keys(); // ['foo', {baz: 'baz'}]</code></pre><p><strong>values()</strong></p>
<p>This will return a list of the current keys in cache.</p>
<pre class="prettyprint source lang-javascript"><code>const memoized = moize((item) => {
  return {
    item
  };
});

const foo = 'foo';

memoized(foo);

const bar = {
  baz: 'baz'
};

memoized(bar);

const values = memoized.values(); // [{item: 'foo'}, {item: {baz: 'baz'}}]</code></pre><h3 id="benchmarks">Benchmarks</h3>
<p>All values provided are the number of operations per second (ops/sec) calculated by the <a href="https://benchmarkjs.com/">Benchmark suite</a>. Note that <code>underscore</code>, <code>lodash</code>, and <code>ramda</code> do not support mulitple-parameter memoization, so they are not included in those benchmarks. Each benchmark was performed using the default configuration of the library, with a fibonacci calculation based on a starting parameter of 35, and in the case of multiple parameters a second parameter (<code>boolean</code> for primitives, <code>object</code> for complex objects) was used.</p>
<p><img src="img/single-parameter.png" alt="Single parameter image"></p>
<table>
<thead>
<tr>
<th>underscore</th>
<th>lodash</th>
<th>ramda</th>
<th>memoizee</th>
<th>fast-memoize</th>
<th>addy-osmani</th>
<th>memoizerific</th>
<th>moize</th>
</tr>
</thead>
<tbody>
<tr>
<td>9,313,172</td>
<td>10,063,753</td>
<td>1,072,901</td>
<td>11,145,989</td>
<td>31,208,485</td>
<td>3,755,775</td>
<td>2,157,874</td>
<td>40,188,210</td>
</tr>
</tbody>
</table>
<p><img src="img/multiple-parameter-primitives.png" alt="Multiple primitive parameters image"></p>
<table>
<thead>
<tr>
<th>memoizee</th>
<th>fast-memoize</th>
<th>addy-osmani</th>
<th>memoizerific</th>
<th>moize</th>
</tr>
</thead>
<tbody>
<tr>
<td>8,018,360</td>
<td>1,239,470</td>
<td>1,681,101</td>
<td>1,359,196</td>
<td>6,815,215</td>
</tr>
</tbody>
</table>
<p><img src="img/multiple-parameter-complex.png" alt="Multiple complex parameters image"></p>
<table>
<thead>
<tr>
<th>memoizee</th>
<th>fast-memoize</th>
<th>addy-osmani</th>
<th>memoizerific</th>
<th>moize</th>
</tr>
</thead>
<tbody>
<tr>
<td>7,198,600</td>
<td>877,440</td>
<td>810,924</td>
<td>1,208,660</td>
<td>6,011,380</td>
</tr>
</tbody>
</table>
<p><em>NOTE: benchmarks posted prior were inaccurate for <code>memoizee</code> and <code>memoizerific</code>, as it turns out I was creating new objects instead of using the same ones (sorry). The updated benchmarks are an accurate reflection of default usage.</em></p>
<h3 id="browser-support">Browser support</h3>
<ul>
<li>Chrome (all versions)</li>
<li>Firefox (all versions)</li>
<li>Opera 15+</li>
<li>Edge (all versions)</li>
<li>IE 9+</li>
<li>Safari 6+</li>
</ul>
<p>Theoretically the support should go back even farther, these are just the environments that I have tested.</p>
<h3 id="development">Development</h3>
<p>Standard stuff, clone the repo and <code>npm install</code> dependencies. The npm scripts available:</p>
<ul>
<li><code>build</code> =&gt; run webpack to build development <code>dist</code> file with NODE_ENV=development</li>
<li><code>build:minifed</code> =&gt; run webpack to build production <code>dist</code> file with NODE_ENV=production</li>
<li><code>dev</code> =&gt; run webpack dev server to run example app (playground!)</li>
<li><code>dist</code> =&gt; runs <code>build</code> and <code>build-minified</code></li>
<li><code>docs</code> =&gt; builds the docs via <code>jsdoc</code></li>
<li><code>lint</code> =&gt; run ESLint against all files in the <code>src</code> folder</li>
<li><code>prepublish</code> =&gt; runs <code>compile-for-publish</code></li>
<li><code>prepublish:compile</code> =&gt; run <code>lint</code>, <code>test</code>, <code>transpile</code>, <code>dist</code></li>
<li><code>test</code> =&gt; run AVA test functions with <code>NODE_ENV=test</code></li>
<li><code>test:coverage</code> =&gt; run <code>test</code> but with <code>nyc</code> for coverage checker</li>
<li><code>test:watch</code> =&gt; run <code>test</code>, but with persistent watcher</li>
<li><code>transpile</code> =&gt; run babel against all files in <code>src</code> to create files in <code>lib</code></li>
</ul></article>
    </section>







		</div>
	</div>

	<div class="clearfix"></div>

	
		<div class="col-md-3">
			<div id="toc" class="col-md-3 hidden-xs hidden-sm hidden-md"></div>
		</div>
	

</div>
</div>


    <div class="modal fade" id="searchResults">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="modal-header">
            <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
            <h4 class="modal-title">Search results</h4>
          </div>
          <div class="modal-body"></div>
          <div class="modal-footer">
            <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
          </div>
        </div><!-- /.modal-content -->
      </div><!-- /.modal-dialog -->
    </div>


<footer>


<span class="jsdoc-message">
	Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a>
	
	using the <a href="https://github.com/docstrap/docstrap">DocStrap template</a>.
</span>
</footer>

<script src="scripts/docstrap.lib.js"></script>
<script src="scripts/toc.js"></script>

    <script type="text/javascript" src="scripts/fulltext-search-ui.js"></script>


<script>
$( function () {
	$( "[id*='$']" ).each( function () {
		var $this = $( this );

		$this.attr( "id", $this.attr( "id" ).replace( "$", "__" ) );
	} );

	$( ".tutorial-section pre, .readme-section pre, pre.prettyprint.source" ).each( function () {
		var $this = $( this );

		var example = $this.find( "code" );
		exampleText = example.html();
		var lang = /{@lang (.*?)}/.exec( exampleText );
		if ( lang && lang[1] ) {
			exampleText = exampleText.replace( lang[0], "" );
			example.html( exampleText );
			lang = lang[1];
		} else {
			var langClassMatch = example.parent()[0].className.match(/lang\-(\S+)/);
			lang = langClassMatch ? langClassMatch[1] : "javascript";
		}

		if ( lang ) {

			$this
			.addClass( "sunlight-highlight-" + lang )
			.addClass( "linenums" )
			.html( example.html() );

		}
	} );

	Sunlight.highlightAll( {
		lineNumbers : true,
		showMenu : true,
		enableDoclinks : true
	} );

	$.catchAnchorLinks( {
        navbarOffset: 10
	} );
	$( "#toc" ).toc( {
		anchorName  : function ( i, heading, prefix ) {
			return $( heading ).attr( "id" ) || ( prefix + i );
		},
		selectors   : "#toc-content h1,#toc-content h2,#toc-content h3,#toc-content h4",
		showAndHide : false,
		smoothScrolling: true
	} );

	$( "#main span[id^='toc']" ).addClass( "toc-shim" );
	$( '.dropdown-toggle' ).dropdown();

    $( "table" ).each( function () {
      var $this = $( this );
      $this.addClass('table');
    } );

} );
</script>



<!--Navigation and Symbol Display-->

<script>
	$( function () {
		$( '#main' ).localScroll( {
			offset : { top : 60 } //offset by the height of your header (give or take a few px, see what works for you)
		} );
		$( "dt.name" ).each( function () {
			var $this = $( this ).find("h4");
			var icon = $( "<i/>" ).addClass( "icon-plus-sign" ).addClass( "pull-right" ).addClass( "icon-white" );
			var dt = $(this);
			var children = dt.next( "dd" );

			dt.prepend( icon ).css( {cursor : "pointer"} );
			dt.addClass( "member-collapsed" ).addClass( "member" );


			children.hide();

			dt.children().on( "click", function () {
				children = dt.next( "dd" );
				children.slideToggle( "fast", function () {

					if ( children.is( ":visible" ) ) {
						icon.addClass( "icon-minus-sign" ).removeClass( "icon-plus-sign" ).removeClass( "icon-white" );
						dt.addClass( "member-open" ).animate( "member-collapsed" );
					} else {
						icon.addClass( "icon-plus-sign" ).removeClass( "icon-minus-sign" ).addClass( "icon-white" );
						dt.addClass( "member-collapsed" ).removeClass( "member-open" );
					}
				} );
			} );

		} );
	} );
</script>


<!--Google Analytics-->



    <script type="text/javascript">
        $(document).ready(function() {
            SearcherDisplay.init();
        });
    </script>


</body>
</html>